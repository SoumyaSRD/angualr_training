import{b as s}from"./chunk-TCLAS7TI.js";import"./chunk-IDUW3PRR.js";import{Cb as e,Oa as r,eb as l,fb as t,gb as n}from"./chunk-2OVPXQV3.js";var d={title:"Angular Modules vs Standalone Components: A Detailed Comparison",tags:["Angular","Modules","Standalone Components","Architecture","Comparison","Best Practices"],paragraphs:["Angular offers two primary ways to organize and structure components: traditional NgModules and the newer standalone components. Introduced in Angular 14 and made default in later versions, standalone components simplify development by reducing boilerplate and improving modularity. This content provides a detailed comparison between Angular modules and standalone components, highlighting their differences, benefits, use cases, and migration strategies."],keyPoints:["Modules: Group related components, directives, pipes, and services; require declarations and imports in NgModule.","Standalone Components: Self-contained with direct imports; no need for NgModules, reducing boilerplate.","Key Differences: Boilerplate, tree-shaking, dependency management, and application structure.","Benefits: Modules for grouping tightly coupled features; Standalone for simplicity and better optimization.","Migration: Incremental adoption possible, with tools to convert from modules to standalone."],sections:[{id:"what-are-modules",heading:"What Are Angular Modules?",content:"Angular modules (NgModules) are containers that group related components, directives, pipes, and services. They have been a core part of Angular since version 2, providing a way to organize code, manage dependencies, and enable features like lazy loading.",list:["Declared using @NgModule decorator","Include declarations, imports, exports, and providers arrays","Support module types like root, feature, shared, and core","Enable compilation contexts for components"],additionalExplanation:"Modules promote modularity but can lead to more boilerplate code, especially in larger applications."},{id:"what-are-standalone-components",heading:"What Are Standalone Components?",content:"Standalone components, introduced in Angular 14, allow components, directives, and pipes to exist independently without being declared in an NgModule. They are marked with 'standalone: true' and handle their own dependencies via an imports array.",list:["Default in Angular 17+ for new projects","Simplify structure by eliminating module files","Support direct imports of other standalone entities or modules","Compatible with routing and lazy loading without modules"],additionalExplanation:"Standalone components streamline development, making Angular more accessible to newcomers and reducing unnecessary code."},{id:"key-differences",heading:"Key Differences",content:"While both approaches serve to organize Angular applications, they differ in setup, flexibility, and performance implications.",list:["Boilerplate: Modules require separate module files; Standalone integrates everything in the component file.","Dependency Management: Modules use imports/declarations at module level; Standalone uses imports directly in the component.","Tree-Shaking: Standalone components are more tree-shakeable, leading to smaller bundles.","Grouping: Modules excel at bundling related features; Standalone promotes individual, reusable entities.","Compatibility: Modules are backward-compatible; Standalone can be mixed with modules."],additionalExplanation:"In large projects, standalone components allow for finer-grained control, ensuring components are only loaded where needed."},{id:"benefits-and-use-cases",heading:"Benefits and Use Cases",content:"Choosing between modules and standalone depends on project size, team preferences, and specific requirements.",list:["Modules: Ideal for grouping tightly coupled components (e.g., a feature module with multiple related views).","Standalone: Better for simple apps, micro-frontends, or when minimizing boilerplate; enhances tree-shaking and scalability.","Hybrid Approach: Use modules for legacy code and standalone for new features."],additionalExplanation:"For large enterprises, standalone reduces complexity, while modules provide structure for complex shared logic."},{id:"migration",heading:"Migration from Modules to Standalone",content:"Angular supports incremental migration, allowing coexistence of both approaches.",list:["Use Angular CLI schematics like ng generate --standalone","Convert components by adding standalone: true and moving imports","Update bootstrapping to use bootstrapApplication for module-less apps","Remove unnecessary NgModules after conversion"],additionalExplanation:"The standalone migration schematic automates much of the process, making it easier to modernize existing applications."}],codeExamples:[{title:"Module-Based Component Example",language:"typescript",code:`import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ExampleComponent } from './example.component';

@NgModule({
  declarations: [ExampleComponent],
  imports: [CommonModule],
  exports: [ExampleComponent]
})
export class ExampleModule { }`,description:"A traditional module declaring and exporting a component."},{title:"Standalone Component Example",language:"typescript",code:`import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-example',
  standalone: true,
  imports: [CommonModule],
  template: \`<p>Example Standalone Component</p>\`
})
export class ExampleComponent { }`,description:"A standalone component with direct imports, no module required."},{title:"Module-Based Bootstrap Example",language:"typescript",code:`import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { AppModule } from './app.module';

platformBrowserDynamic().bootstrapModule(AppModule)
  .catch(err => console.error(err));`,description:"Bootstrapping an application using a root module."},{title:"Standalone Bootstrap Example",language:"typescript",code:`import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app.component';

bootstrapApplication(AppComponent)
  .catch(err => console.error(err));`,description:"Bootstrapping an application directly with a standalone component."}],bestPractices:["Use standalone components for new projects to reduce boilerplate and improve performance.","Reserve modules for grouping components that are always used together.","Adopt a hybrid approach during migration to avoid disruptions.","Leverage Angular's migration tools for converting existing module-based code.","Monitor bundle sizes and tree-shaking effectiveness when choosing an approach.","Follow Angular Architects' recommendation: Prefer standalone for new components."]};var h=(()=>{class a{constructor(){this.content=d}static{this.\u0275fac=function(i){return new(i||a)}}static{this.\u0275cmp=r({type:a,selectors:[["app-standalone"]],decls:54,vars:7,consts:[[3,"title","tags","paragraphs","sections","codeExamples","bestPractices","keyPoints"]],template:function(i,o){i&1&&(t(0,"app-topic-template",0)(1,"p"),e(2," Angular applications can be built using either traditional NgModule-based architecture or the newer standalone component approach. NgModules were originally designed to organize components, directives, pipes, and services into cohesive units. Standalone components, introduced in Angular 14 and becoming the default in Angular 17+, simplify this architecture by allowing components to exist independently without requiring NgModule declarations. "),n(),t(3,"p"),e(4," The module-based approach focuses on grouping related functionality into structured modules, which helps with large-scale organization but often introduces additional boilerplate and complexity. In contrast, standalone components declare their own dependencies directly using the "),t(5,"code"),e(6,"imports"),n(),e(7," property, making them more self-contained and easier to manage. Both approaches can coexist, and developers can choose based on project requirements or gradually migrate toward standalone architecture. "),n(),t(8,"h3"),e(9,"Module vs Standalone Components"),n(),t(10,"ul")(11,"li")(12,"strong"),e(13,"Structure:"),n(),e(14," NgModules require components to be declared inside a module, while standalone components operate independently. "),n(),t(15,"li")(16,"strong"),e(17,"Boilerplate:"),n(),e(18," Module-based architecture involves additional configuration files; standalone reduces setup complexity. "),n(),t(19,"li")(20,"strong"),e(21,"Dependency Management:"),n(),e(22," NgModules manage shared dependencies centrally, whereas standalone components define imports locally. "),n(),t(23,"li")(24,"strong"),e(25,"Lazy Loading:"),n(),e(26," Modules traditionally handle lazy loading; standalone components enable direct lazy loading via router configuration. "),n(),t(27,"li")(28,"strong"),e(29,"Learning Curve:"),n(),e(30," NgModules introduce extra concepts for new developers; standalone offers a simpler mental model. "),n(),t(31,"li")(32,"strong"),e(33,"Flexibility:"),n(),e(34," Standalone promotes modular, reusable, and composable design patterns. "),n()(),t(35,"h3"),e(36,"When to Use Each Approach"),n(),t(37,"ul")(38,"li")(39,"strong"),e(40,"Use NgModules:"),n(),e(41," When working with legacy applications or large teams already structured around module architecture. "),n(),t(42,"li")(43,"strong"),e(44,"Use Standalone Components:"),n(),e(45," For new projects, modern Angular best practices, and simpler project setup. "),n(),t(46,"li")(47,"strong"),e(48,"Hybrid Approach:"),n(),e(49," Angular supports mixing both approaches, allowing gradual migration without rewriting existing features. "),n()(),t(50,"h3"),e(51,"Summary"),n(),t(52,"p"),e(53," While NgModules remain a valid organizational tool, standalone components represent Angular's modern direction by reducing complexity and improving developer experience. Understanding both approaches helps developers maintain legacy systems while adopting newer, more efficient patterns. "),n()()),i&2&&l("title",o.content.title)("tags",o.content.tags)("paragraphs",o.content.paragraphs)("sections",o.content.sections)("codeExamples",o.content.codeExamples)("bestPractices",o.content.bestPractices)("keyPoints",o.content.keyPoints)},dependencies:[s],encapsulation:2})}}return a})();export{h as ModuleStandalone};
