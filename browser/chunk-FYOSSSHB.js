import{b as m}from"./chunk-TCLAS7TI.js";import"./chunk-IDUW3PRR.js";import{Aa as s,Cb as e,Oa as c,eb as a,fb as n,gb as t,hb as r}from"./chunk-2OVPXQV3.js";var p={title:"RxJS Higher-Order Operators Deep Dive: mergeMap, switchMap, concatMap, exhaustMap, combineLatest & forkJoin",tags:["RxJS","Angular","mergeMap","switchMap","concatMap","exhaustMap","combineLatest","forkJoin","Higher-Order Operators","Reactive Programming"],paragraphs:["Higher-order mapping operators are among the most powerful \u2014 and most frequently misunderstood \u2014 tools in RxJS. They allow you to map each value from a source Observable to a new inner Observable, and then decide how to combine/flatten the emissions from those inner Observables. Choosing the right one dramatically affects performance, memory usage, race conditions, and correctness of your application. This guide explains mergeMap, switchMap, concatMap, exhaustMap, combineLatest, and forkJoin in depth: how they behave, when to use each, real Angular use cases, marble diagrams intuition, common pitfalls, and best practices."],keyPoints:["mergeMap \u2192 runs all inner Observables concurrently, no cancellation","switchMap \u2192 cancels previous inner Observable, only latest one matters","concatMap \u2192 queues inner Observables, preserves order, waits for completion","exhaustMap \u2192 ignores new values while inner Observable is active","combineLatest \u2192 emits when ANY source emits, combines latest values","forkJoin \u2192 waits for ALL Observables to complete, emits once with all results"],sections:[{id:"mergeMap",heading:"mergeMap (also known as flatMap)",content:"Projects each source value to an Observable and merges all emissions concurrently.",list:["No cancellation of previous inner Observables","All inner Observables run in parallel","Emits values as soon as any inner Observable emits","Can produce many concurrent subscriptions","Memory leak risk if inner Observables never complete"],additionalExplanation:"Use when you want every request/action to complete independently (parallel execution, no cancellation needed). Less common in modern Angular than switchMap."},{id:"switchMap",heading:"switchMap \u2013 The Most Used in Angular",content:"Maps to inner Observable and switches to the new one, cancelling the previous inner subscription.",list:["Cancels previous inner Observable when new source value arrives","Only the latest inner Observable matters","Prevents race conditions","Ideal for search, type-ahead, dependent API calls, user input \u2192 HTTP"],additionalExplanation:"switchMap is the go-to operator for most user-triggered async operations in Angular \u2014 it ensures you always get the result of the latest action."},{id:"concatMap",heading:"concatMap",content:"Maps to inner Observable and queues them \u2014 processes one at a time, in order.",list:["Waits for previous inner Observable to complete before starting next","Preserves order of emissions","No concurrency \u2014 safe but can feel slow","Good when order matters and you cannot lose requests"],additionalExplanation:"Use when sequence is important (e.g., save operations that must happen in order)."},{id:"exhaustMap",heading:"exhaustMap",content:"Maps to inner Observable, but ignores new source values while inner is active.",list:["Only one inner Observable runs at a time","New values are dropped until current inner completes","Prevents overlapping / spam (great for button clicks)","Common use: 'Submit' button while request is processing"],additionalExplanation:"exhaustMap protects against rapid repeated actions \u2014 the first action wins, others are ignored until it finishes."},{id:"combineLatest",heading:"combineLatest",content:"Combines multiple Observables \u2014 emits whenever ANY of them emits, using the latest value from each.",list:["Requires all sources to have emitted at least once","Emits on every change of any source","Great for reactive forms with multiple dependent fields","Can be memory-intensive if sources emit very frequently"],additionalExplanation:"Classic use case: combine form control values or multiple API states."},{id:"forkJoin",heading:"forkJoin",content:"Waits for ALL Observables to complete, then emits once with an array/object of last values.",list:["Like Promise.all for Observables","Only emits when every source completes","If any source errors \u2192 whole forkJoin errors","Perfect for loading independent data in parallel"],additionalExplanation:"Very common in Angular for loading user profile + roles + settings at once."}],codeExamples:[{title:"switchMap \u2013 Search / Type-ahead (most common pattern)",language:"typescript",code:`this.searchTerm$.pipe(
  debounceTime(350),
  distinctUntilChanged(),
  switchMap(term => 
    this.http.get<SearchResult[]>(\`/api/search?q=\${term}\`).pipe(
      catchError(() => of([]))
    )
  )
).subscribe(results => this.results = results);`,description:"Latest search term cancels previous request \u2192 no race conditions"},{title:"concatMap \u2013 Ordered sequential saves",language:"typescript",code:`this.form.valueChanges.pipe(
  concatMap(value => this.http.post('/api/save', value))
).subscribe(response => console.log('Saved:', response));`,description:"Each change is saved only after the previous save completes"},{title:"exhaustMap \u2013 Prevent button spam",language:"typescript",code:`fromEvent(this.submitButton, 'click').pipe(
  exhaustMap(() => this.http.post('/api/submit', this.form.value))
).subscribe(...);`,description:"While submit is in progress, additional clicks are ignored"},{title:"forkJoin \u2013 Load multiple independent resources",language:"typescript",code:`forkJoin({
  user: this.userService.getCurrentUser(),
  permissions: this.authService.getPermissions(),
  config: this.configService.getAppConfig()
}).subscribe(results => {
  this.user = results.user;
  this.permissions = results.permissions;
});`,description:"Waits for all to finish, emits once"},{title:"combineLatest \u2013 React to multiple form controls",language:"typescript",code:`combineLatest([
  this.form.get('startDate')!.valueChanges,
  this.form.get('endDate')!.valueChanges
]).pipe(
  filter(([start, end]) => !!start && !!end),
  switchMap(([start, end]) => this.http.get<Report>(\`/report?start=\${start}&end=\${end}\`))
).subscribe(report => this.report = report);`,description:"Re-runs query whenever either date changes"}],bestPractices:["Use **switchMap** for most user-triggered async operations (search, filter, route params \u2192 data load)","Use **concatMap** when order is important and you cannot afford to drop requests","Use **exhaustMap** to protect against rapid repeated user actions (clicks, submits)","Use **mergeMap** only when you really want all inner Observables to run in parallel without cancellation","Always put **catchError** inside the inner observable in mapping operators","Prefer **combineLatestWith** or **combineLatest** when combining 2\u20135 streams","Use **forkJoin** when you need all data before proceeding (initial page load)","Avoid mergeMap without limits \u2014 can create many concurrent HTTP calls","Combine higher-order operators with **debounceTime**, **distinctUntilChanged**, **takeUntil**","Modern Angular: Consider signals + toObservable() when simple mapping is enough"]};var v=(()=>{class o{constructor(){this.content=p,this.mergeMapExample=`
source$.pipe(
  mergeMap(value => http.get('/api/' + value))
).subscribe(console.log);
`,this.switchMapExample=`
searchInput$.pipe(
  switchMap(term => http.get('/search?q=' + term))
).subscribe(console.log);
`,this.concatMapExample=`
saveQueue$.pipe(
  concatMap(data => http.post('/save', data))
).subscribe();
`,this.exhaustMapExample=`
click$.pipe(
  exhaustMap(() => http.post('/login'))
).subscribe();
`,this.combineLatestExample=`
combineLatest([obs1$, obs2$]).subscribe(([a, b]) => {
  console.log(a, b);
});
`,this.forkJoinExample=`
forkJoin({
  users: http.get('/users'),
  posts: http.get('/posts')
}).subscribe(result => console.log(result));
`}static{this.\u0275fac=function(l){return new(l||o)}}static{this.\u0275cmp=c({type:o,selectors:[["app-rxjs-flattening"]],decls:163,vars:13,consts:[[3,"title","tags","paragraphs","sections","codeExamples","bestPractices","keyPoints"],[3,"textContent"]],template:function(l,i){l&1&&(n(0,"app-topic-template",0)(1,"h3"),e(2,"Introduction to RxJS Higher-Order Mapping & Combination Operators"),t(),n(3,"p"),e(4," RxJS provides powerful operators that help manage complex asynchronous workflows by transforming, combining, and controlling streams of data. Operators such as "),n(5,"code"),e(6,"mergeMap"),t(),e(7,", "),n(8,"code"),e(9,"switchMap"),t(),e(10,", "),n(11,"code"),e(12,"concatMap"),t(),e(13,", "),n(14,"code"),e(15,"exhaustMap"),t(),e(16,", "),n(17,"code"),e(18,"combineLatest"),t(),e(19,", and "),n(20,"code"),e(21,"forkJoin"),t(),e(22," are commonly used in Angular applications, especially when working with HTTP requests, user events, or reactive forms. "),t(),n(23,"p"),e(24," These operators allow developers to work with higher-order Observables (Observables that emit other Observables) and control how multiple streams interact with each other. Understanding when and how to use each operator is essential for writing efficient and predictable reactive code. "),t(),n(25,"h3"),e(26,"Higher-Order Mapping Operators"),t(),n(27,"p"),e(28," Higher-order mapping operators transform emitted values into new Observables and then flatten them into a single stream. Each operator defines a different strategy for handling concurrent emissions. "),t(),n(29,"h4"),e(30,"1. mergeMap"),t(),n(31,"p")(32,"code"),e(33,"mergeMap"),t(),e(34," subscribes to all inner Observables simultaneously and merges their results into one output stream. It is useful when multiple asynchronous tasks can run in parallel. "),t(),n(35,"ul")(36,"li"),e(37,"Allows multiple concurrent inner subscriptions."),t(),n(38,"li"),e(39,"Does not cancel previous requests."),t(),n(40,"li"),e(41,"Ideal for parallel API calls."),t()(),n(42,"pre"),r(43,"code",1),e(44,`
`),t(),n(45,"h4"),e(46,"2. switchMap"),t(),n(47,"p")(48,"code"),e(49,"switchMap"),t(),e(50," switches to a new inner Observable whenever a new value is emitted and cancels the previous one. This makes it perfect for search inputs or scenarios where only the latest result matters. "),t(),n(51,"ul")(52,"li"),e(53,"Cancels previous inner subscriptions."),t(),n(54,"li"),e(55,"Ensures only the latest emission is processed."),t(),n(56,"li"),e(57,"Commonly used for live search/autocomplete."),t()(),n(58,"pre"),r(59,"code",1),e(60,`
`),t(),n(61,"h4"),e(62,"3. concatMap"),t(),n(63,"p")(64,"code"),e(65,"concatMap"),t(),e(66," queues inner Observables and executes them one after another in order. It ensures sequential processing and preserves order. "),t(),n(67,"ul")(68,"li"),e(69,"Processes tasks sequentially."),t(),n(70,"li"),e(71,"Maintains execution order."),t(),n(72,"li"),e(73,"Useful when order matters (e.g., saving data step-by-step)."),t()(),n(74,"pre"),r(75,"code",1),e(76,`
`),t(),n(77,"h4"),e(78,"4. exhaustMap"),t(),n(79,"p")(80,"code"),e(81,"exhaustMap"),t(),e(82," ignores new emissions while a current inner Observable is active. It is useful when you want to prevent repeated triggers such as multiple button clicks. "),t(),n(83,"ul")(84,"li"),e(85,"Ignores new emissions until current completes."),t(),n(86,"li"),e(87,"Prevents duplicate requests."),t(),n(88,"li"),e(89,"Useful for login or form submission actions."),t()(),n(90,"pre"),r(91,"code",1),e(92,`
`),t(),n(93,"h3"),e(94,"Combination Operators"),t(),n(95,"p"),e(96," Combination operators merge multiple Observables into a single stream, allowing developers to coordinate data from different sources. "),t(),n(97,"h4"),e(98,"5. combineLatest"),t(),n(99,"p")(100,"code"),e(101,"combineLatest"),t(),e(102," emits values whenever any input Observable emits, but only after all Observables have emitted at least once. It combines the latest values from each stream. "),t(),n(103,"ul")(104,"li"),e(105,"Emits whenever any source emits."),t(),n(106,"li"),e(107,"Uses latest values from all sources."),t(),n(108,"li"),e(109,"Useful for combining form inputs or UI state."),t()(),n(110,"pre"),r(111,"code",1),e(112,`
`),t(),n(113,"h4"),e(114,"6. forkJoin"),t(),n(115,"p")(116,"code"),e(117,"forkJoin"),t(),e(118," waits for all Observables to complete and then emits a single combined result. It behaves similarly to "),n(119,"code"),e(120,"Promise.all()"),t(),e(121,". "),t(),n(122,"ul")(123,"li"),e(124,"Waits for all observables to complete."),t(),n(125,"li"),e(126,"Emits once with final values."),t(),n(127,"li"),e(128,"Ideal for loading multiple API calls together."),t()(),n(129,"pre"),r(130,"code",1),e(131,`
`),t(),n(132,"h3"),e(133,"When to Use Each Operator"),t(),n(134,"ul")(135,"li")(136,"strong"),e(137,"mergeMap:"),t(),e(138," Parallel requests or independent async tasks."),t(),n(139,"li")(140,"strong"),e(141,"switchMap:"),t(),e(142," Latest-only operations like search inputs."),t(),n(143,"li")(144,"strong"),e(145,"concatMap:"),t(),e(146," Sequential processing where order matters."),t(),n(147,"li")(148,"strong"),e(149,"exhaustMap:"),t(),e(150," Ignore repeated triggers during execution."),t(),n(151,"li")(152,"strong"),e(153,"combineLatest:"),t(),e(154," Combine latest values from multiple streams."),t(),n(155,"li")(156,"strong"),e(157,"forkJoin:"),t(),e(158," Wait for all tasks to finish before continuing."),t()(),n(159,"h3"),e(160,"Summary"),t(),n(161,"p"),e(162," RxJS mapping and combination operators provide powerful tools for handling complex asynchronous workflows in Angular applications. Choosing the right operator depends on how you want to manage concurrency, ordering, and data combination. Mastering these operators helps developers build efficient, scalable, and reactive applications. "),t()()),l&2&&(a("title",i.content.title)("tags",i.content.tags)("paragraphs",i.content.paragraphs)("sections",i.content.sections)("codeExamples",i.content.codeExamples)("bestPractices",i.content.bestPractices)("keyPoints",i.content.keyPoints),s(43),a("textContent",i.mergeMapExample),s(16),a("textContent",i.switchMapExample),s(16),a("textContent",i.concatMapExample),s(16),a("textContent",i.exhaustMapExample),s(20),a("textContent",i.combineLatestExample),s(19),a("textContent",i.forkJoinExample))},dependencies:[m],encapsulation:2})}}return o})();export{v as RxjsFlattening};
