import{b as m}from"./chunk-LDGWIROF.js";import"./chunk-XGBKVH7G.js";import{Aa as r,Cb as e,Eb as s,Oa as d,U as l,V as c,eb as p,fb as n,gb as t}from"./chunk-ESOSN4X2.js";var u={title:"Angular Dependency Injection (DI): Complete Guide with Deep Explanation, Examples, and Best Practices",tags:["Angular","Dependency Injection","DI","Providers","Injectors","Services","Injection Tokens","Best Practices","Architecture"],paragraphs:["Dependency Injection (DI) is one of the most powerful and fundamental design patterns in Angular. It is the mechanism that Angular uses to provide and manage dependencies across your application in a clean, testable, and maintainable way. DI eliminates the need to manually create instances of services, components, or other objects, allowing Angular to handle instantiation, scoping, and lifecycle automatically. This comprehensive guide covers everything you need to know about Angular's dependency injection system: how it works, the injector hierarchy, provider types, injection tokens, hierarchical injectors, providedIn syntax, standalone components DI, advanced patterns, and best practices to build scalable, testable Angular applications."],keyPoints:["Dependency Injection: A design pattern where dependencies are provided to a class instead of the class creating them itself.","Injector Hierarchy: Angular creates a tree of injectors mirroring the component tree, enabling scoped and hierarchical dependency resolution.","Providers: Define how to create and provide instances (useClass, useValue, useFactory, useExisting).","providedIn: 'root' vs 'providedIn: SomeModule' vs providedIn: 'platform' vs providedIn: 'any'.","Injection Tokens: Used to provide and inject non-class dependencies (constants, functions, configurations).","Standalone DI: Modern Angular (14+) simplifies DI with direct imports and bootstrapApplication providers.","Testing: DI makes unit testing extremely easy by allowing easy mocking of dependencies."],sections:[{id:"what-is-dependency-injection",heading:"What is Dependency Injection?",content:"Dependency Injection is a technique in which an object receives its dependencies from an external source rather than creating them itself. In Angular, the DI system is responsible for creating instances of services, resolving their dependencies, and injecting them where needed \u2014 typically into constructors of components, directives, pipes, or other services.",list:["Promotes loose coupling between classes","Makes code easier to test (mock dependencies)","Centralizes configuration and instance management","Enables reusability and modularity","Automatically handles singleton vs transient behavior"],additionalExplanation:"Without DI, you would manually instantiate services inside components (new MyService()), leading to tight coupling, hard-to-test code, and duplicated creation logic. Angular's DI solves all of these problems elegantly."},{id:"how-angular-di-works",heading:"How Angular's Dependency Injection Works",content:"Angular maintains a hierarchical tree of injectors that parallels the component tree. When a class requests a dependency via constructor injection, Angular looks for it first in the component's injector, then walks up the tree to parent injectors, all the way to the root injector.",list:["Root Injector: Created at application bootstrap, provides application-wide singletons","Module Injectors: Each NgModule can have its own injector (providers array)","Component Injectors: Every component and directive has its own injector","Resolution Path: Child \u2192 Parent \u2192 Grandparent \u2192 ... \u2192 Root","providedIn: 'root' = singleton at root level"],additionalExplanation:"This hierarchical system allows different parts of the app to have different instances of the same service (scoped DI) or share a single instance (singleton behavior)."},{id:"providers-and-registration",heading:"Providers \u2013 How to Register Dependencies",content:"Providers tell Angular how to create and deliver an instance when a dependency is requested. They can be defined in @NgModule, @Component, @Directive, or via providedIn.",list:["useClass: Provide an alternative implementation (great for mocking)","useValue: Provide a static value (configs, constants)","useFactory: Dynamic creation logic (useful for conditional providers)","useExisting: Alias one token to another","providedIn: 'root' \u2192 application-wide singleton (most common)","providedIn: 'platform' \u2192 shared across multiple Angular apps","providedIn: 'any' \u2192 one instance per lazy-loaded module","providedIn: SomeModule \u2192 scoped to that module"],additionalExplanation:"The providedIn syntax (introduced in Angular 6) is now the recommended way to register services because it enables tree-shaking and eliminates the need to add services to the providers array manually."},{id:"injection-tokens",heading:"Injection Tokens \u2013 Non-Class Dependencies",content:"Not all dependencies are classes. For values, functions, or configurations, you use InjectionToken to create a unique token that can be provided and injected.",list:["const API_URL = new InjectionToken<string>('API_URL');","Provide using { provide: API_URL, useValue: 'https://api.example.com' }","Inject using @Inject(API_URL) private apiUrl: string","Very useful for environment configs, themes, feature flags, etc."],additionalExplanation:"InjectionToken gives type safety and prevents naming collisions when providing primitive values or objects."},{id:"standalone-components-di",heading:"Dependency Injection in Standalone Components",content:"In modern Angular (14+), standalone components and applications eliminate NgModules in many cases. DI is configured directly at bootstrap or via imports.",list:["bootstrapApplication(AppComponent, { providers: [...] })","Environment providers: importProvidersFrom(), provideRouter(), provideHttpClient()","Component-level providers still work: @Component({ providers: [...] })","Services with providedIn: 'root' continue to work seamlessly"],additionalExplanation:"Standalone DI reduces boilerplate, improves tree-shaking, and aligns with the direction of modern Angular development."},{id:"advanced-di-patterns",heading:"Advanced DI Patterns and Techniques",content:"Angular's DI system supports powerful patterns for complex applications.",list:["Multi providers: Provide multiple values under the same token (multi: true)","Optional dependencies: @Optional() \u2013 doesn't throw if missing","SkipSelf: @SkipSelf() \u2013 looks only in parent injectors","Self: @Self() \u2013 looks only in own injector","Host: @Host() \u2013 looks up to the host component injector","Factory providers with dependencies: useFactory with deps array"],additionalExplanation:"These modifiers give fine-grained control over where Angular looks for dependencies \u2014 critical in deeply nested or library scenarios."}],codeExamples:[{title:"Basic Service with providedIn: 'root'",language:"typescript",code:`import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class DataService {
  getData() {
    return ['Item 1', 'Item 2'];
  }
}`,description:"Most common and recommended way to create a singleton service."},{title:"Component-Level Provider (Scoped Instance)",language:"typescript",code:`@Component({
  selector: 'app-user',
  template: '...',
  providers: [UserService] // new instance for this component and children
})
export class UserComponent {
  constructor(private userService: UserService) {}
}`,description:"Each instance of UserComponent gets its own UserService instance."},{title:"Injection Token + useValue Example",language:"typescript",code:`import { InjectionToken } from '@angular/core';

export const APP_CONFIG = new InjectionToken<AppConfig>('AppConfig');

export interface AppConfig {
  apiUrl: string;
  timeout: number;
}

// In bootstrap or module providers:
{ provide: APP_CONFIG, useValue: { apiUrl: 'https://api.com', timeout: 5000 } }

// In component/service:
constructor(@Inject(APP_CONFIG) private config: AppConfig) {}`,description:"Safe, type-safe way to inject configuration objects."},{title:"Standalone Application Bootstrap with Providers",language:"typescript",code:`import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter } from '@angular/router';
import { provideHttpClient } from '@angular/common/http';
import { AppComponent } from './app.component';
import { routes } from './app.routes';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes),
    provideHttpClient(),
    { provide: 'API_KEY', useValue: 'xyz123' }
  ]
});`,description:"Modern way to bootstrap a standalone Angular application with DI."}],bestPractices:["Use providedIn: 'root' for most services that should be singletons.","Use component-level providers only when you intentionally need scoped instances.","Prefer InjectionToken for configurations, constants, and non-class dependencies.","Avoid large provider arrays in components \u2014 prefer root or module-level when possible.","Leverage @Optional(), @SkipSelf(), etc. only when needed and document their usage.","Always provide mocks in unit tests using TestBed.configureTestingModule({ providers: [...] }).","Use environment files + InjectionToken for different build configurations (dev, prod).","Keep services small and focused \u2014 follow single responsibility principle.","In standalone apps, centralize most providers at bootstrapApplication level.","Monitor DI tree complexity in large apps \u2014 avoid deep unnecessary scoping."]};var I=(()=>{class o{constructor(){this.content=u,this.dataEg=`
@Injectable({
  providedIn: 'root'
})
export class DataService {
  getMessage() {
    return 'Hello from service!';
  }
}
`,this.dataEg2=`constructor(private dataService: DataService) {}

ngOnInit() {
  console.log(this.dataService.getMessage());
}`}static{this.\u0275fac=function(a){return new(a||o)}}static{this.\u0275cmp=d({type:o,selectors:[["app-di-service"]],decls:141,vars:9,consts:[[3,"title","tags","paragraphs","sections","codeExamples","bestPractices","keyPoints"]],template:function(a,i){a&1&&(n(0,"app-topic-template",0)(1,"h3"),e(2,"Dependency Injection (DI) in Angular"),t(),n(3,"p"),e(4," Dependency Injection (DI) is a core design pattern in Angular that allows classes to receive their required dependencies from external sources rather than creating them manually. This approach promotes loose coupling between different parts of an application, improves code reusability, and makes testing easier. Instead of instantiating services directly inside a component, Angular provides them automatically through its built-in dependency injection system. "),t(),n(5,"p"),e(6," In Angular, dependencies are typically services that contain shared logic, data access functionality, configuration, or state management. The Angular framework uses an injector to create and manage instances of these services and supply them wherever they are needed. "),t(),n(7,"h3"),e(8,"Why Dependency Injection is Important"),t(),n(9,"ul")(10,"li")(11,"strong"),e(12,"Loose Coupling:"),t(),e(13," Components do not need to know how to create their dependencies."),t(),n(14,"li")(15,"strong"),e(16,"Reusability:"),t(),e(17," Services can be reused across multiple components."),t(),n(18,"li")(19,"strong"),e(20,"Maintainability:"),t(),e(21," Easier to update or replace services without changing dependent components."),t(),n(22,"li")(23,"strong"),e(24,"Testability:"),t(),e(25," Dependencies can be mocked or replaced during testing."),t(),n(26,"li")(27,"strong"),e(28,"Centralized Management:"),t(),e(29," Angular manages lifecycle and instantiation automatically."),t()(),n(30,"h3"),e(31,"How Dependency Injection Works"),t(),n(32,"p"),e(33,"Angular's DI system consists of three main parts:"),t(),n(34,"ul")(35,"li")(36,"strong"),e(37,"Service:"),t(),e(38," A class that provides functionality or data."),t(),n(39,"li")(40,"strong"),e(41,"Injector:"),t(),e(42," Responsible for creating and delivering service instances."),t(),n(43,"li")(44,"strong"),e(45,"Consumer:"),t(),e(46," A component, directive, pipe, or another service that requires the dependency. "),t()(),n(47,"p"),e(48," When Angular creates a component, it checks the constructor parameters and automatically injects the required dependencies if they are registered with the injector. "),t(),n(49,"h3"),e(50,"Creating and Injecting a Service"),t(),n(51,"h4"),e(52,"Step 1: Create a Service"),t(),n(53,"pre"),e(54),t(),n(55,"p"),e(56," The "),n(57,"code"),e(58,"providedIn: 'root'"),t(),e(59," configuration registers the service in the root injector, making it available throughout the application as a singleton. "),t(),n(60,"h4"),e(61,"Step 2: Inject Service into Component"),t(),n(62,"pre"),e(63),t(),n(64,"p"),e(65," Angular automatically resolves the dependency and injects the service instance into the component. "),t(),n(66,"h3"),e(67,"Types of Providers in Angular"),t(),n(68,"ul")(69,"li")(70,"strong"),e(71,"Root Provider:"),t(),e(72," Registered globally using "),n(73,"code"),e(74,"providedIn: 'root'"),t(),e(75,"."),t(),n(76,"li")(77,"strong"),e(78,"Component Provider:"),t(),e(79," Local instance scoped to component tree."),t(),n(80,"li")(81,"strong"),e(82,"Module Provider:"),t(),e(83," Used in legacy NgModule-based apps."),t()(),n(84,"h3"),e(85,"Injector Hierarchy"),t(),n(86,"p"),e(87," Angular uses a hierarchical injector system. Child components can access services from parent injectors or override them locally. "),t(),n(88,"ul")(89,"li"),e(90,"Root Injector \u2014 global application services."),t(),n(91,"li"),e(92,"Component Injectors \u2014 scoped services."),t()(),n(93,"h3"),e(94,"Modern Dependency Injection (Angular Standalone)"),t(),n(95,"p"),e(96," With standalone components, DI still works the same way. Angular also introduced the "),n(97,"code"),e(98,"inject()"),t(),e(99," function for functional injection. "),t(),n(100,"pre"),c(),e(101,`const dataService = inject(DataService);
`),l(),t(),n(102,"h3"),e(103,"Advanced DI Concepts"),t(),n(104,"ul")(105,"li")(106,"strong"),e(107,"Injection Tokens:"),t(),e(108," For non-class dependencies."),t(),n(109,"li")(110,"strong"),e(111,"Optional Injection:"),t(),e(112," Prevent errors if dependency missing."),t(),n(113,"li")(114,"strong"),e(115,"Multi Providers:"),t(),e(116," Multiple values under one token."),t(),n(117,"li")(118,"strong"),e(119,"Factory Providers:"),t(),e(120," Dynamic creation logic."),t()(),n(121,"h3"),e(122,"Best Practices"),t(),n(123,"ul")(124,"li"),e(125,"Use services for shared logic."),t(),n(126,"li"),e(127,"Prefer "),n(128,"code"),e(129,"providedIn: 'root'"),t(),e(130,"."),t(),n(131,"li"),e(132,"Avoid heavy business logic in components."),t(),n(133,"li"),e(134,"Scope services only when needed."),t(),n(135,"li"),e(136,"Keep services single-responsibility."),t()(),n(137,"h3"),e(138,"Summary"),t(),n(139,"p"),e(140," Dependency Injection keeps Angular applications modular, scalable, and easy to maintain by separating dependency creation from usage. "),t()()),a&2&&(p("title",i.content.title)("tags",i.content.tags)("paragraphs",i.content.paragraphs)("sections",i.content.sections)("codeExamples",i.content.codeExamples)("bestPractices",i.content.bestPractices)("keyPoints",i.content.keyPoints),r(54),s("",i.dataEg,`
`),r(9),s("",i.dataEg2,`
`))},dependencies:[m],encapsulation:2})}}return o})();export{I as DiServiceExample};
