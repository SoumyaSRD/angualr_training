import{b as u}from"./chunk-RU5UJ4ZI.js";import{Ka as l,ab as d,bb as n,cb as t,wb as e,xa as i,yb as o}from"./chunk-6SFLLJLD.js";var c={title:"Angular Routing & Navigation: Comprehensive Guide with Deep Details, Examples, and Best Practices",tags:["Angular","Routing","Navigation","Router","Lazy Loading","Guards","Resolvers","Route Parameters","Best Practices","Performance"],paragraphs:["Routing and navigation are central to building modern single-page applications (SPAs) in Angular. The Angular Router enables declarative navigation, lazy loading of feature modules, parameterized routes, route guards for security and control, data pre-fetching with resolvers, and much more. Mastering routing is essential for creating scalable, performant, and user-friendly Angular applications. This in-depth guide covers every major aspect of Angular routing: core concepts, configuration patterns, route parameters, child routes, lazy loading, guards, resolvers, programmatic navigation, auxiliary routes, route reuse strategies, modern standalone routing, and proven best practices to help you build robust navigation systems."],keyPoints:["RouterModule: The core module that provides routing capabilities.","Routes Configuration: Array of route definitions with path, component, children, loadChildren, etc.","Lazy Loading: Load feature modules only when needed \u2192 dramatically improves initial load time.","Route Parameters & Query Params: Dynamic data in URLs (/:id, ?search=term).","Route Guards: CanActivate, CanMatch, CanDeactivate, Resolve, CanLoad for security and data control.","Resolvers: Pre-fetch data before activating a route.","Router Events & Navigation Lifecycle: Intercept navigation, handle errors, show loaders.","Standalone Routing: Modern Angular (14+) eliminates NgModule dependency for routing."],sections:[{id:"what-is-angular-routing",heading:"What is Angular Routing?",content:"The Angular Router is a powerful service that enables navigation between different views (components) within a single-page application. Instead of full page reloads, it updates the URL and renders the appropriate component based on the current route.",list:["Declarative routing in templates using <router-outlet> and routerLink","Supports deep linking and browser history (back/forward buttons)","Handles parameterized routes, query parameters, fragments","Enables lazy loading of feature modules","Provides guards, resolvers, and navigation events"],additionalExplanation:"Routing transforms Angular from a component-based UI library into a full-featured SPA framework. It manages the entire navigation lifecycle, from URL change to component activation and data resolution."},{id:"basic-routing-setup",heading:"Basic Routing Setup & Configuration",content:"Routing is configured using an array of Route objects, typically in a dedicated routing module or directly in standalone applications.",list:["RouterModule.forRoot(routes) \u2192 root-level configuration","RouterModule.forChild(routes) \u2192 feature/child modules","<router-outlet> \u2192 placeholder where routed components render","routerLink directive \u2192 declarative navigation","RouterLinkActive \u2192 highlights active route"],additionalExplanation:"In modern Angular (17+), routing can be fully functional and standalone with provideRouter() and createRoutesFromChildren()."},{id:"route-parameters",heading:"Route Parameters & Query Parameters",content:"Dynamic routes use parameters to pass data through the URL.",list:["Path parameters: /user/:id \u2192 ActivatedRoute.snapshot.paramMap.get('id')","Query parameters: /products?category=books&sort=price \u2192 ActivatedRoute.queryParams","Fragment: /help#section2 \u2192 ActivatedRoute.fragment","ActivatedRoute & ActivatedRouteSnapshot for accessing route data"],additionalExplanation:"Use paramMap for required data, queryParams for optional filters. Prefer route params for identifying resources (RESTful style)."},{id:"child-routes-nested-routing",heading:"Child Routes & Nested Routing",content:"Child routes enable nested layouts (e.g., sidebar + content) and organized feature routing.",list:["children: [] array inside a parent route","Named router-outlets for multiple content areas",'Relative navigation with routerLink="./child"',"Common pattern: feature module with its own routing file"],additionalExplanation:"Nested routes are essential for complex dashboards, admin panels, and tabbed interfaces."},{id:"lazy-loading",heading:"Lazy Loading \u2013 Performance Optimization",content:"Lazy loading defers loading of feature modules until the user navigates to them, significantly reducing initial bundle size.",list:["loadChildren: () => import('./feature/feature.module').then(m => m.FeatureModule)","Preloading strategies: PreloadAllModules, custom preloading","CanLoad guard for protecting lazy routes","Automatic chunk creation during build"],additionalExplanation:"Lazy loading is one of the most impactful performance optimizations in large Angular applications."},{id:"route-guards",heading:"Route Guards \u2013 Security & Control",content:"Guards decide whether a route can be activated, loaded, or deactivated.",list:["CanActivate / CanActivateChild: protect route access","CanMatch: choose which route to activate","CanDeactivate: prevent leaving unsaved forms","CanLoad: protect lazy-loaded modules (prevents loading)","Resolve: fetch data before activation"],additionalExplanation:"Guards are commonly used for authentication, role-based access, and preventing data loss."},{id:"resolvers",heading:"Resolvers \u2013 Data Pre-fetching",content:"Resolvers fetch data before a route is activated, ensuring components receive ready data.",list:["Implement Resolve<T> interface","Return Observable, Promise, or value","Data available via ActivatedRoute.snapshot.data","Combine with async pipe in templates"],additionalExplanation:"Resolvers improve UX by avoiding loading states in components and centralize data fetching logic."},{id:"standalone-routing",heading:"Standalone Routing (Modern Angular)",content:"Since Angular 14+, routing can be fully configured without NgModules using provideRouter().",list:["provideRouter(routes) in bootstrapApplication","createRoutesFromChildren() for modular route definitions","Functional guards, resolvers, and interceptors","importProvidersFrom() for legacy module interop"],additionalExplanation:"Standalone routing reduces boilerplate, improves tree-shaking, and is the future direction of Angular."}],codeExamples:[{title:"Basic Standalone Routing Setup",language:"typescript",code:`import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter } from '@angular/router';
import { AppComponent } from './app.component';

const routes = [
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', component: HomeComponent },
  { path: 'about', component: AboutComponent }
];

bootstrapApplication(AppComponent, {
  providers: [provideRouter(routes)]
});`,description:"Modern way to bootstrap routing in a standalone application."},{title:"Lazy Loaded Feature Route",language:"typescript",code:`const routes: Routes = [
  {
    path: 'products',
    loadChildren: () => import('./products/products.routes').then(m => m.PRODUCTS_ROUTES)
  }
];

// products.routes.ts
export const PRODUCTS_ROUTES: Routes = [
  { path: '', component: ProductListComponent },
  { path: ':id', component: ProductDetailComponent }
];`,description:"Recommended lazy loading pattern with separate route files."},{title:"Auth Guard Example",language:"typescript",code:`import { inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { AuthService } from './auth.service';

export const authGuard: CanActivateFn = () => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.isLoggedIn()) {
    return true;
  }
  router.navigate(['/login']);
  return false;
};`,description:"Functional CanActivate guard (modern style)."},{title:"Resolver Example",language:"typescript",code:`import { ResolveFn } from '@angular/router';
import { inject } from '@angular/core';
import { UserService } from './user.service';

export const userResolver: ResolveFn<User> = (route) => {
  const userService = inject(UserService);
  const id = route.params['id'];
  return userService.getUser(id);
};`,description:"Resolver that fetches user data before route activation."}],bestPractices:["Use standalone routing and provideRouter() for new projects.","Organize routes into separate files per feature (feature.routes.ts).","Always lazy load feature modules in medium/large applications.","Use functional guards and resolvers in modern Angular.","Centralize route constants (paths, roles) to avoid magic strings.","Handle navigation errors and show loading spinners using Router events.","Prefer route params over query params for required identifiers.","Use pathMatch: 'full' for redirects and exact matches.","Implement CanDeactivate for unsaved changes protection.","Monitor bundle sizes \u2013 lazy loading should create meaningful chunks.","Use title strategy or Route data for dynamic page titles.","Combine with signals and async pipe for reactive route data handling."]};var f=(()=>{class r{constructor(){this.content=c,this.dataParamEg=`constructor(private route: ActivatedRoute) {}

ngOnInit() {
  const id = this.route.snapshot.paramMap.get('id');
}`,this.dataEg=`{
  path: 'dashboard',
  component: Dashboard,
  children: [
    { path: 'stats', component: StatsComponent }
  ]
}`,this.dataNavEg=`constructor(private router: Router) {}

goToProfile() {
  this.router.navigate(['/profile', 1]);
}`,this.dataRoutingEg=`export const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'about', component: AboutComponent },
  { path: 'profile/:id', component: ProfileComponent }
];`,this.dataLazyEg=`{
  path: 'admin',
  loadComponent: () => import('./admin.component')
    .then(m => m.AdminComponent)
}s`}static{this.\u0275fac=function(s){return new(s||r)}}static{this.\u0275cmp=l({type:r,selectors:[["app-routing"]],decls:129,vars:12,consts:[[3,"title","tags","paragraphs","sections","codeExamples","bestPractices","keyPoints"]],template:function(s,a){s&1&&(n(0,"app-topic-template",0)(1,"h3"),e(2,"Routing & Navigation in Angular"),t(),n(3,"p"),e(4," Routing and navigation are essential features in Angular that enable the creation of Single Page Applications (SPAs). Instead of reloading the entire page when navigating between views, Angular dynamically updates the content within the application using its built-in Router. This provides faster navigation, better performance, and a smoother user experience. "),t(),n(5,"p"),e(6," Angular Router allows developers to map URLs to specific components, manage application states, enable lazy loading, handle route guards for security, and control navigation programmatically. It plays a crucial role in structuring large applications by dividing them into multiple views or pages. "),t(),n(7,"h3"),e(8,"Key Concepts of Angular Routing"),t(),n(9,"ul")(10,"li")(11,"strong"),e(12,"Routes:"),t(),e(13," Define mappings between URL paths and components. "),t(),n(14,"li")(15,"strong"),e(16,"Router Outlet:"),t(),e(17," Placeholder directive where routed components are displayed. "),t(),n(18,"li")(19,"strong"),e(20,"RouterLink:"),t(),e(21," Directive used to navigate between routes. "),t(),n(22,"li")(23,"strong"),e(24,"Navigation:"),t(),e(25," Programmatic or declarative movement between views. "),t(),n(26,"li")(27,"strong"),e(28,"Route Parameters:"),t(),e(29," Dynamic values passed through URLs. "),t()(),n(30,"h3"),e(31,"Basic Routing Setup"),t(),n(32,"p"),e(33," In modern Angular (standalone architecture), routes are typically defined in a separate routes configuration file. Each route specifies a path and the component that should be displayed when that path is accessed. "),t(),n(34,"pre"),e(35),t(),n(36,"h3"),e(37,"Router Outlet"),t(),n(38,"p"),e(39," The "),n(40,"code"),e(41,"<router-outlet>"),t(),e(42," directive acts as a dynamic container where Angular renders the component associated with the active route. "),t(),n(43,"pre"),e(44,`<router-outlet></router-outlet>
`),t(),n(45,"h3"),e(46,"Navigation Using RouterLink"),t(),n(47,"p"),e(48," Angular provides the "),n(49,"code"),e(50,"routerLink"),t(),e(51," directive for declarative navigation. It allows users to navigate between routes without reloading the page. "),t(),n(52,"pre"),e(53,`<a routerLink="/about">Go to About</a>
`),t(),n(54,"h3"),e(55,"Programmatic Navigation"),t(),n(56,"p"),e(57," Developers can navigate using the Router service, which is useful when navigation depends on logic or events such as form submissions. "),t(),n(58,"pre"),e(59),t(),n(60,"h3"),e(61,"Route Parameters"),t(),n(62,"p"),e(63," Route parameters allow dynamic data to be passed through URLs. Components can access these parameters using the ActivatedRoute service. "),t(),n(64,"pre"),e(65),t(),n(66,"h3"),e(67,"Child Routes and Nested Routing"),t(),n(68,"p"),e(69," Angular supports nested routes, allowing complex layouts with multiple router outlets. Child routes help organize related views under a parent route. "),t(),n(70,"pre"),e(71),t(),n(72,"h3"),e(73,"Lazy Loading Routes"),t(),n(74,"p"),e(75," Lazy loading improves performance by loading feature modules or standalone components only when required. This reduces initial bundle size and speeds up application startup. "),t(),n(76,"pre"),e(77),t(),n(78,"h3"),e(79,"Route Guards"),t(),n(80,"p"),e(81," Route guards control access to routes based on conditions such as authentication or permissions. Angular provides several guard types: "),t(),n(82,"ul")(83,"li")(84,"strong"),e(85,"CanActivate:"),t(),e(86," Prevents unauthorized access."),t(),n(87,"li")(88,"strong"),e(89,"CanDeactivate:"),t(),e(90," Prevents leaving a route."),t(),n(91,"li")(92,"strong"),e(93,"Resolve:"),t(),e(94," Fetches data before navigation."),t(),n(95,"li")(96,"strong"),e(97,"CanLoad:"),t(),e(98," Controls lazy-loaded routes."),t()(),n(99,"h3"),e(100,"Navigation Events"),t(),n(101,"p"),e(102," Angular Router emits events during navigation such as start, end, cancel, or error events. Developers can subscribe to these events for logging, loading indicators, or analytics. "),t(),n(103,"h3"),e(104,"Modern Routing (Standalone Angular)"),t(),n(105,"p"),e(106," Modern Angular applications use "),n(107,"code"),e(108,"provideRouter()"),t(),e(109," during application bootstrap instead of module-based routing. This aligns with the standalone architecture and reduces boilerplate. "),t(),n(110,"pre"),e(111,`
`),t(),n(112,"h3"),e(113,"Best Practices for Routing"),t(),n(114,"ul")(115,"li"),e(116," Use lazy loading for large feature areas. "),t(),n(117,"li"),e(118," Organize routes logically to improve maintainability. "),t(),n(119,"li"),e(120," Protect sensitive routes using guards. "),t(),n(121,"li"),e(122," Use route parameters instead of global state when possible. "),t(),n(123,"li"),e(124," Keep route configuration simple and readable. "),t()(),n(125,"h3"),e(126,"Summary"),t(),n(127,"p"),e(128," Angular Routing enables efficient navigation and dynamic view rendering in single-page applications. By mapping URLs to components, supporting lazy loading, and providing advanced navigation features, Angular Router helps developers build scalable, performant, and user-friendly applications. "),t()()),s&2&&(d("title",a.content.title)("tags",a.content.tags)("paragraphs",a.content.paragraphs)("sections",a.content.sections)("codeExamples",a.content.codeExamples)("bestPractices",a.content.bestPractices)("keyPoints",a.content.keyPoints),i(35),o("",a.dataRoutingEg,`
`),i(24),o("",a.dataNavEg,`
`),i(6),o("",a.dataParamEg,`
`),i(6),o("        ",a.dataEg,`

`),i(6),o("",a.dataLazyEg,`
`))},dependencies:[u],encapsulation:2})}}return r})();export{f as Routing};
