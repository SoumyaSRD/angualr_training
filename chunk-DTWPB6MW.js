import{b as c}from"./chunk-RU5UJ4ZI.js";import{Ka as m,ab as a,bb as n,cb as t,db as l,wb as e,xa as o}from"./chunk-6SFLLJLD.js";var p={title:"Observable vs Promise in Angular: Deep Comparison, Use Cases, Performance & Best Practices",tags:["Angular","RxJS","Observable","Promise","Async","Reactive Programming","Comparison","Best Practices"],paragraphs:["Handling asynchronous operations is at the heart of modern web applications, especially in Angular. Two of the most common tools for managing async data are **Promise** (native JavaScript) and **Observable** (from RxJS). While both can represent values that arrive over time, they differ significantly in philosophy, capabilities, flexibility, and usage patterns. This in-depth guide compares Observables and Promises head-to-head: their core differences, lifecycle, cancellation, multiple values, error handling, operators, Angular integration (especially with async pipe), when to use which, real-world use cases, performance considerations, and best practices to help you write cleaner, more powerful, and maintainable Angular applications."],keyPoints:["Promise: Represents a single future value (or error) \u2014 one-time operation.","Observable: Represents a stream of values over time \u2014 can emit 0, 1, many, or infinite values.","Lazy vs Eager: Promises start executing immediately; Observables are lazy (cold) by default.","Cancellation: Promises cannot be cancelled; Observables support unsubscribe().","Operators: Observables come with rich RxJS operators (map, filter, switchMap, debounceTime, etc.).","Angular Integration: async pipe works natively with Observables, not Promises.","Multiple Values: Observables shine for real-time data, user input, HTTP retries, websockets."],sections:[{id:"core-differences",heading:"Core Differences \u2013 Promise vs Observable",content:"The fundamental design philosophies are very different.",list:["Values: Promise \u2192 exactly one value (or error), Observable \u2192 zero to infinite values","Creation: new Promise((resolve, reject) => \u2026), new Observable(subscriber => \u2026)","Execution: Promise executes immediately (eager), Observable waits for subscribe() (lazy/cold)","Completion: Promise always completes (success or error), Observable can complete or never complete","Cancellation: Promise \u2014 no native cancellation, Observable \u2014 unsubscribe() stops emissions","Chaining: Promise \u2014 .then().catch(), Observable \u2014 pipe() with operators","Multiple subscribers: Promise \u2014 result is cached after completion, Observable \u2014 unicast by default (cold), multicast possible"],additionalExplanation:"Think of Promise as 'I will give you one answer later'. Observable is 'I will keep sending you data whenever something happens \u2014 until you tell me to stop'."},{id:"lifecycle-comparison",heading:"Lifecycle & Behavior Comparison",content:"Understanding the lifecycle helps decide which tool fits your use case.",list:["Promise: Pending \u2192 Fulfilled / Rejected (terminal states)","Observable: Not started \u2192 Subscribed \u2192 Next (0..n) \u2192 Error / Complete (can be long-lived)","Error handling: Promise \u2014 catch(), Observable \u2014 catchError() operator","Finalization: Promise \u2014 no finally (use .then().catch().finally() in modern JS), Observable \u2014 finalize() operator","Retry: Promise \u2014 manual retry logic, Observable \u2014 retry(), retryWhen() operators"],additionalExplanation:"Observables are ideal for long-lived or repeating sources (user typing, timers, websockets, mouse moves). Promises are better for one-shot operations (simple HTTP GET without retry)."},{id:"cancellation",heading:"Cancellation \u2013 A Major Differentiator",content:"Cancellation is where Observables shine compared to Promises.",list:["Promise: No built-in cancellation \u2192 runs to completion even if component is destroyed","Observable: unsubscribe() stops emissions, prevents memory leaks","Angular async pipe: Automatically subscribes & unsubscribes Observables","take(1), first(), takeUntil(destroy$) \u2014 common patterns to limit lifetime"],additionalExplanation:"In Angular, forgetting to unsubscribe from Observables used to cause memory leaks \u2014 today async pipe + takeUntil(destroy$) pattern solves this elegantly."},{id:"angular-integration",heading:"How Angular Loves Observables",content:"Angular is built with Observables in mind (thanks to RxJS being deeply integrated).",list:["HttpClient returns Observable by default","async pipe works natively with Observable (not Promise)","Forms \u2014 valueChanges, statusChanges are Observables","Router events, animations, event bindings \u2014 all Observables","NgRx, signals interoperability, state management \u2014 all RxJS-based"],additionalExplanation:"Using async pipe + Observable is the idiomatic Angular way \u2014 clean templates, automatic subscription management, no manual unsubscribe."}],codeExamples:[{title:"Promise \u2013 Simple One-Time Operation",language:"typescript",code:`getUser(id: number): Promise<User> {
  return fetch(\`/api/users/\${id}\`)
    .then(res => {
      if (!res.ok) throw new Error('Failed');
      return res.json();
    });
}

// Usage
getUser(123)
  .then(user => console.log(user))
  .catch(err => console.error(err));`,description:"Classic Promise pattern \u2014 single value or error."},{title:"Observable \u2013 HttpClient (Angular way)",language:"typescript",code:`getUser(id: number): Observable<User> {
  return this.http.get<User>(\`/api/users/\${id}\`).pipe(
    catchError(err => {
      console.error(err);
      return throwError(() => new Error('User fetch failed'));
    })
  );
}

// Template
<ng-container *ngIf="user$ | async as user">
  {{ user.name }}
</ng-container>`,description:"Angular idiomatic Observable with async pipe."},{title:"Observable vs Promise \u2013 Cancellation",language:"typescript",code:`// Observable - cancellable
this.subscription = this.http.get('/data').subscribe(...);
// later
this.subscription.unsubscribe();

// Promise - no cancellation
const promise = fetch('/data');
// no way to stop it`,description:"Demonstrates why Observables are better for component lifecycle management."},{title:"Multiple Values \u2013 Observable shines",language:"typescript",code:`fromEvent(document, 'mousemove')
  .pipe(
    throttleTime(100),
    map((e: MouseEvent) => ({ x: e.clientX, y: e.clientY }))
  )
  .subscribe(pos => console.log('Mouse at:', pos));

// Promise cannot handle continuous values`,description:"Observable naturally handles streams (events, timers, websockets)."}],bestPractices:["Use Observables for almost everything in Angular (HttpClient, forms, events, state).","Use async pipe whenever possible \u2014 prevents memory leaks automatically.","Prefer Observables over Promises when you might need retry, debounce, throttle, switchMap, etc.","Use Promise only for very simple, one-time, non-Angular APIs that return Promise.","Convert Promise to Observable when needed: from(promise) or defer(() => from(promise)).","Always clean up long-lived Observables: takeUntil(destroy$), take(1), first(), async pipe.","Use shareReplay(1) or share() when multiple subscribers should get the same data.","Avoid nested subscriptions \u2014 use operators (switchMap, mergeMap, concatMap, exhaustMap).","Handle errors centrally with catchError() \u2014 show user-friendly messages.","Modern Angular (16+): Consider signals + toObservable() / toSignal() for simpler state."]};var g=(()=>{class r{constructor(){this.content=p,this.promiseExample=`
const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve('Promise resolved!'), 1000);
});

promise.then(result => console.log(result));
`,this.observableExample=`
const observable = new Observable(observer => {
  observer.next('First value');
  observer.next('Second value');
  observer.complete();
});

observable.subscribe(value => console.log(value));
`}static{this.\u0275fac=function(s){return new(s||r)}}static{this.\u0275cmp=m({type:r,selectors:[["app-observable-promise"]],decls:103,vars:9,consts:[[3,"title","tags","paragraphs","sections","codeExamples","bestPractices","keyPoints"],[3,"textContent"]],template:function(s,i){s&1&&(n(0,"app-topic-template",0)(1,"h3"),e(2,"Observable vs Promise Introduction"),t(),n(3,"p"),e(4," Observables and Promises are both used in Angular and JavaScript to handle asynchronous operations such as HTTP requests, user events, timers, and data streams. While they may seem similar at first, they serve different purposes and offer different capabilities. Understanding the differences between Observables and Promises is essential for building reactive, scalable, and efficient Angular applications. "),t(),n(5,"p"),e(6," Promises represent a single future value that will eventually be resolved or rejected, whereas Observables represent streams of data that can emit multiple values over time. Angular heavily relies on Observables through the RxJS library, especially for HTTP communication and reactive programming patterns. "),t(),n(7,"h3"),e(8,"What is a Promise?"),t(),n(9,"p"),e(10," A Promise is a JavaScript object that represents the eventual completion or failure of an asynchronous operation. Once resolved, a promise delivers a single value and cannot emit additional values afterward. "),t(),n(11,"pre"),l(12,"code",1),e(13,`
`),t(),n(14,"h4"),e(15,"Key Characteristics of Promises"),t(),n(16,"ul")(17,"li"),e(18,"Handles a single asynchronous result."),t(),n(19,"li"),e(20,"Executes immediately once created."),t(),n(21,"li"),e(22,"Cannot be cancelled once started."),t(),n(23,"li"),e(24,"Uses "),n(25,"code"),e(26,"then()"),t(),e(27,", "),n(28,"code"),e(29,"catch()"),t(),e(30,", and "),n(31,"code"),e(32,"finally()"),t(),e(33,"."),t(),n(34,"li"),e(35,"Common in plain JavaScript APIs."),t()(),n(36,"h3"),e(37,"What is an Observable?"),t(),n(38,"p"),e(39," An Observable is a powerful abstraction provided by RxJS that represents a stream of asynchronous data over time. Observables can emit multiple values, support cancellation, and provide advanced operators for transforming and combining data streams. "),t(),n(40,"pre"),l(41,"code",1),e(42,`
`),t(),n(43,"h4"),e(44,"Key Characteristics of Observables"),t(),n(45,"ul")(46,"li"),e(47,"Can emit multiple values over time."),t(),n(48,"li"),e(49,"Lazy execution (runs only when subscribed)."),t(),n(50,"li"),e(51,"Supports cancellation via unsubscribe."),t(),n(52,"li"),e(53,"Provides powerful operators like map, filter, debounce, etc."),t(),n(54,"li"),e(55,"Heavily used in Angular HTTP and reactive programming."),t()(),n(56,"h3"),e(57,"Key Differences Between Observable and Promise"),t(),n(58,"ul")(59,"li")(60,"strong"),e(61,"Execution:"),t(),e(62," Promises execute immediately; Observables execute only when subscribed. "),t(),n(63,"li")(64,"strong"),e(65,"Values:"),t(),e(66," Promises resolve once; Observables can emit multiple values. "),t(),n(67,"li")(68,"strong"),e(69,"Cancellation:"),t(),e(70," Promises cannot be cancelled; Observables can be unsubscribed. "),t(),n(71,"li")(72,"strong"),e(73,"Operators:"),t(),e(74," Observables provide rich operators for data transformation. "),t(),n(75,"li")(76,"strong"),e(77,"Angular Usage:"),t(),e(78," Angular commonly uses Observables with HTTP and reactive forms. "),t()(),n(79,"h3"),e(80,"When to Use Promise"),t(),n(81,"ul")(82,"li"),e(83,"Simple one-time asynchronous operations."),t(),n(84,"li"),e(85,"Working with standard JavaScript APIs."),t(),n(86,"li"),e(87,"When reactive streams are not required."),t()(),n(88,"h3"),e(89,"When to Use Observable"),t(),n(90,"ul")(91,"li"),e(92,"Handling streams of events or data."),t(),n(93,"li"),e(94,"HTTP requests in Angular."),t(),n(95,"li"),e(96,"Reactive programming scenarios."),t(),n(97,"li"),e(98,"Real-time updates or user interactions."),t()(),n(99,"h3"),e(100,"Summary"),t(),n(101,"p"),e(102," While Promises are useful for handling single asynchronous results, Observables provide a more powerful and flexible approach for managing multiple asynchronous data streams. Angular promotes Observables because they enable reactive patterns, better cancellation control, and advanced data handling capabilities. Understanding both concepts helps developers choose the right tool based on application requirements. "),t()()),s&2&&(a("title",i.content.title)("tags",i.content.tags)("paragraphs",i.content.paragraphs)("sections",i.content.sections)("codeExamples",i.content.codeExamples)("bestPractices",i.content.bestPractices)("keyPoints",i.content.keyPoints),o(12),a("textContent",i.promiseExample),o(29),a("textContent",i.observableExample))},dependencies:[c],encapsulation:2})}}return r})();export{g as ObservablePromise};
