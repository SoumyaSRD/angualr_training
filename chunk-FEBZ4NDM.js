import{a as p}from"./chunk-KUX6U2KE.js";import"./chunk-MMO3VR6A.js";import{Eb as a,Fb as i,Gb as t,Hb as o,Wa as r,ec as e,jb as c}from"./chunk-HJWRZBIA.js";var m={title:"RxJS Operators in Angular: Complete In-Depth Guide \u2013 Categories, Most Important Operators, Examples & Best Practices",tags:["Angular","RxJS","Operators","Reactive Programming","Transformation","Filtering","Combination","Error Handling","Utility","Best Practices"],paragraphs:["RxJS operators are the heart of reactive programming in Angular. They allow you to transform, filter, combine, handle errors, and manage streams of data (Observables) in a clean, declarative, and powerful way. Operators are pure functions that take an Observable as input, modify its behavior or data, and return a new Observable. This comprehensive guide covers the most important RxJS operators grouped by category: transformation, filtering, combination, multicasting, error handling, utility, conditional, and mathematical. You'll find detailed explanations, real-world Angular use cases, common patterns, pitfalls, and best practices to help you write efficient, readable, and maintainable reactive code."],keyPoints:["Operators are chained using .pipe()","Most operators are pure \u2014 they do not mutate the source Observable","Categories: Transformation (map, pluck), Filtering (filter, debounceTime), Combination (mergeMap, switchMap), Multicasting (shareReplay), Error Handling (catchError, retry), Utility (tap, finalize)","Higher-order mapping operators: mergeMap, concatMap, switchMap, exhaustMap \u2014 critical for Angular HTTP and async operations","Angular loves RxJS: HttpClient, forms valueChanges, router events, async pipe \u2014 all built around Observables and operators"],sections:[{id:"transformation-operators",heading:"Transformation Operators",content:"Change the data emitted by the Observable.",list:["map: Transforms each value (like Array.map)","pluck: Extracts a property from objects (deprecated \u2192 use map)","mapTo: Maps every value to a constant","mergeMap / flatMap: Projects each value to an Observable and flattens (concurrent)","switchMap: Cancels previous inner Observable, switches to new one (most common in Angular)","concatMap: Queues inner Observables, waits for completion (ordered)","exhaustMap: Ignores new values while inner Observable is active (e.g. click spam protection)","scan: Accumulates values like reduce over time"],additionalExplanation:"Higher-order mapping operators (mergeMap family) are the most important and most misused in Angular \u2014 choosing the right one prevents memory leaks and race conditions."},{id:"filtering-operators",heading:"Filtering Operators",content:"Decide which values should pass through.",list:["filter: Only emit values that match condition","distinctUntilChanged: Skip duplicate consecutive values","debounceTime: Wait for silence before emitting (search input)","throttleTime: Emit first value, then ignore for duration","take(n): Take first n values then complete","takeUntil(notifier): Complete when notifier emits","skip(n): Skip first n values","ignoreElements: Ignore all next emissions, only complete/error"],additionalExplanation:"debounceTime + distinctUntilChanged is the classic combo for search/autocomplete inputs."},{id:"combination-operators",heading:"Combination / Joining Operators",content:"Combine multiple Observables.",list:["combineLatest: Emit when any source emits (latest values)","withLatestFrom: Pair with latest value from another source","forkJoin: Wait for all Observables to complete (like Promise.all)","merge: Merge emissions from multiple sources concurrently","concat: Concatenate Observables sequentially","zip: Pair values from multiple sources by index","race: Emit from the first Observable that emits"],additionalExplanation:"forkJoin is perfect for loading multiple independent API calls at once."},{id:"multicasting-operators",heading:"Multicasting & Sharing Operators",content:"Share a single execution among multiple subscribers.",list:["share: Multicast with no replay","shareReplay(bufferSize, windowTime): Replay last N values to late subscribers","publish + refCount: Manual multicast (rarely used directly)","multicast + refCount: Low-level control"],additionalExplanation:"shareReplay(1) is the go-to for caching HTTP responses or shared state."},{id:"error-handling-retry",heading:"Error Handling & Retry Operators",content:"Manage errors and retries gracefully.",list:["catchError: Catch and recover from errors","retry(n): Retry n times on error","retryWhen: Advanced retry logic (delay, exponential backoff)","finalize: Run code on complete or error (cleanup)"],additionalExplanation:"Always use catchError in Angular services \u2014 never let errors reach the template."},{id:"utility-debugging",heading:"Utility & Debugging Operators",content:"Side effects, logging, debugging.",list:["tap: Perform side effects (logging, analytics) without changing value","finalize: Cleanup regardless of complete/error","delay: Delay emissions","timeout: Throw error if no value within time"],additionalExplanation:"tap is used for debugging and side effects \u2014 never put business logic in tap."}],codeExamples:[{title:"switchMap \u2013 Most Common Angular Pattern",language:"typescript",code:`this.searchTerm$.pipe(
  debounceTime(300),
  distinctUntilChanged(),
  switchMap(term => this.http.get<User[]>(\`/api/users?q=\${term}\`))
).subscribe(results => this.results = results);`,description:"Search input \u2192 debounce \u2192 cancel previous request \u2192 new search (prevents race conditions)."},{title:"forkJoin \u2013 Parallel API Calls",language:"typescript",code:`forkJoin({
  user: this.http.get<User>('/api/user'),
  posts: this.http.get<Post[]>('/api/posts'),
  settings: this.http.get<Settings>('/api/settings')
}).subscribe(({ user, posts, settings }) => {
  // all completed
});`,description:"Load multiple independent resources at once."},{title:"shareReplay \u2013 Cache HTTP Response",language:"typescript",code:`private products$ = this.http.get<Product[]>('/api/products').pipe(
  shareReplay(1)
);

// Multiple components can subscribe without new HTTP calls
this.products$.subscribe(...);`,description:"Single HTTP call, cached result for all subscribers."},{title:"takeUntil + destroy$ pattern",language:"typescript",code:`private destroy$ = new Subject<void>();

ngOnInit() {
  this.data$.pipe(
    takeUntil(this.destroy$)
  ).subscribe(...);
}

ngOnDestroy() {
  this.destroy$.next();
  this.destroy$.complete();
}`,description:"Safe cleanup pattern (before async pipe became dominant)."}],bestPractices:["Always use .pipe() to chain operators \u2014 improves readability and type safety.","Prefer switchMap for search/autocomplete/API calls \u2014 cancels outdated requests.","Use concatMap when order matters (sequential operations).","Use exhaustMap for click handlers where you want to ignore new clicks during processing.","Never forget catchError in data services \u2014 handle errors gracefully.","Use shareReplay(1) or shareReplay({ bufferSize: 1, refCount: true }) for caching.","Avoid nested subscribe \u2014 flatten with mergeMap/switchMap/etc.","Use async pipe in templates \u2014 automatic subscribe/unsubscribe.","Combine takeUntil(destroy$) or take(1) for manual subscriptions (legacy code).","Debug with tap() + console.log \u2014 but remove before production.","Learn the marble diagrams \u2014 they explain operator behavior perfectly.","Modern Angular (16+): Combine RxJS with signals when appropriate (toSignal, toObservable)."]};var f=(()=>{class l{constructor(){this.content=m,this.pipeExample=`
observable.pipe(
  map(value => value * 2),
  filter(value => value > 10)
).subscribe(result => console.log(result));
`,this.mapExample=`
of(1,2,3).pipe(
  map(x => x * 10)
).subscribe(console.log);
`,this.filterExample=`
of(1,2,3,4).pipe(
  filter(x => x % 2 === 0)
).subscribe(console.log);
`,this.combineExample=`
combineLatest([obs1$, obs2$]).subscribe(([a,b]) => {
  console.log(a, b);
});
`,this.tapExample=`
of('Hello').pipe(
  tap(value => console.log('Debug:', value))
).subscribe();
`}static{this.\u0275fac=function(s){return new(s||l)}}static{this.\u0275cmp=c({type:l,selectors:[["app-rxjs-operator"]],decls:158,vars:12,consts:[[3,"title","tags","paragraphs","sections","codeExamples","bestPractices","keyPoints"],[3,"textContent"]],template:function(s,n){s&1&&(i(0,"app-topic-template",0)(1,"h3"),e(2,"RxJS Operators Introduction"),t(),i(3,"p"),e(4," RxJS Operators are powerful functions used to transform, filter, combine, and manage data streams in reactive programming. In Angular applications, RxJS operators play a crucial role when working with Observables, enabling developers to manipulate asynchronous data in a clean, declarative, and composable way. "),t(),i(5,"p"),e(6," Operators allow you to build complex asynchronous workflows by chaining multiple operations together using the "),i(7,"code"),e(8,"pipe()"),t(),e(9," method. Instead of writing nested callbacks or complex logic, RxJS operators help create readable and maintainable reactive code. "),t(),i(10,"h3"),e(11,"Why Use RxJS Operators?"),t(),i(12,"ul")(13,"li")(14,"strong"),e(15,"Data Transformation:"),t(),e(16," Modify emitted values easily. "),t(),i(17,"li")(18,"strong"),e(19,"Filtering:"),t(),e(20," Emit only specific values based on conditions. "),t(),i(21,"li")(22,"strong"),e(23,"Combining Streams:"),t(),e(24," Merge multiple observables together. "),t(),i(25,"li")(26,"strong"),e(27,"Error Handling:"),t(),e(28," Manage errors gracefully. "),t(),i(29,"li")(30,"strong"),e(31,"Better Readability:"),t(),e(32," Avoid nested callbacks. "),t(),i(33,"li")(34,"strong"),e(35,"Reactive Programming:"),t(),e(36," Build dynamic data pipelines. "),t()(),i(37,"h3"),e(38,"Using Operators with pipe()"),t(),i(39,"p"),e(40," Operators are typically used inside the "),i(41,"code"),e(42,"pipe()"),t(),e(43," method, which allows chaining multiple transformations on an observable. "),t(),i(44,"pre"),o(45,"code",1),e(46,`
`),t(),i(47,"h3"),e(48,"Common Categories of RxJS Operators"),t(),i(49,"h4"),e(50,"1. Transformation Operators"),t(),i(51,"p"),e(52," These operators transform emitted values into new values. "),t(),i(53,"ul")(54,"li")(55,"code"),e(56,"map"),t(),e(57," \u2014 Transform each emitted value."),t(),i(58,"li")(59,"code"),e(60,"switchMap"),t(),e(61," \u2014 Switch to a new observable."),t(),i(62,"li")(63,"code"),e(64,"mergeMap"),t(),e(65," \u2014 Flatten inner observables."),t()(),i(66,"pre"),o(67,"code",1),e(68,`
`),t(),i(69,"h4"),e(70,"2. Filtering Operators"),t(),i(71,"p"),e(72," Used to filter emitted values based on conditions. "),t(),i(73,"ul")(74,"li")(75,"code"),e(76,"filter"),t(),e(77," \u2014 Emit only values matching criteria."),t(),i(78,"li")(79,"code"),e(80,"debounceTime"),t(),e(81," \u2014 Delay emissions to reduce rapid updates."),t(),i(82,"li")(83,"code"),e(84,"distinctUntilChanged"),t(),e(85," \u2014 Ignore duplicate values."),t()(),i(86,"pre"),o(87,"code",1),e(88,`
`),t(),i(89,"h4"),e(90,"3. Combination Operators"),t(),i(91,"p"),e(92," Combine multiple observables into one stream. "),t(),i(93,"ul")(94,"li")(95,"code"),e(96,"combineLatest"),t()(),i(97,"li")(98,"code"),e(99,"forkJoin"),t()(),i(100,"li")(101,"code"),e(102,"merge"),t()()(),i(103,"pre"),o(104,"code",1),e(105,`
`),t(),i(106,"h4"),e(107,"4. Utility Operators"),t(),i(108,"p"),e(109," Used for side effects or debugging without modifying data. "),t(),i(110,"ul")(111,"li")(112,"code"),e(113,"tap"),t(),e(114," \u2014 Perform side effects like logging."),t(),i(115,"li")(116,"code"),e(117,"finalize"),t(),e(118," \u2014 Execute logic when observable completes."),t()(),i(119,"pre"),o(120,"code",1),e(121,`
`),t(),i(122,"h3"),e(123,"Common Angular Use Cases"),t(),i(124,"ul")(125,"li"),e(126," Handling HTTP requests and transforming API responses. "),t(),i(127,"li"),e(128," Managing form input streams. "),t(),i(129,"li"),e(130," Implementing search auto-complete with debounce. "),t(),i(131,"li"),e(132," Combining multiple data sources. "),t(),i(133,"li"),e(134," Handling complex asynchronous workflows. "),t()(),i(135,"h3"),e(136,"Best Practices for Using RxJS Operators"),t(),i(137,"ul")(138,"li"),e(139," Prefer operator chaining using "),i(140,"code"),e(141,"pipe()"),t(),e(142,". "),t(),i(143,"li"),e(144," Use "),i(145,"code"),e(146,"switchMap"),t(),e(147," for API calls to cancel previous requests. "),t(),i(148,"li"),e(149," Avoid deeply nested subscriptions. "),t(),i(150,"li"),e(151," Keep observable streams clean and readable. "),t(),i(152,"li"),e(153," Unsubscribe when necessary to avoid memory leaks. "),t()(),i(154,"h3"),e(155,"Summary"),t(),i(156,"p"),e(157," RxJS operators are essential tools for building reactive Angular applications. They allow developers to manipulate asynchronous data streams efficiently, improve readability, and create scalable reactive pipelines. Mastering RxJS operators enables more advanced control over asynchronous workflows and enhances application performance. "),t()()),s&2&&(a("title",n.content.title)("tags",n.content.tags)("paragraphs",n.content.paragraphs)("sections",n.content.sections)("codeExamples",n.content.codeExamples)("bestPractices",n.content.bestPractices)("keyPoints",n.content.keyPoints),r(45),a("textContent",n.pipeExample),r(22),a("textContent",n.mapExample),r(20),a("textContent",n.filterExample),r(17),a("textContent",n.combineExample),r(16),a("textContent",n.tapExample))},dependencies:[p],encapsulation:2})}}return l})();export{f as RxjsOperator};
