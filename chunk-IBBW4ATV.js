import{g as l}from"./chunk-ZADPXEUX.js";import"./chunk-FEIPXN7P.js";import"./chunk-LMJIRV6F.js";import{b as u}from"./chunk-LDGWIROF.js";import"./chunk-WFO7GJJM.js";import"./chunk-CVNJEO4S.js";import"./chunk-XGBKVH7G.js";import{Aa as s,Cb as e,Oa as d,Ta as m,eb as r,fb as i,gb as t,pb as p}from"./chunk-ESOSN4X2.js";var h={title:"Angular Directives and Custom Directives: Comprehensive Explanation and Implementation Guide",tags:["Angular","Directives","Custom Directives","Structural Directives","Attribute Directives","Architecture","Best Practices"],paragraphs:["Directives in Angular are powerful tools that allow developers to extend HTML with custom behavior, manipulate the DOM, and create reusable UI logic. They are classified into built-in and custom directives, with custom ones enabling tailored functionality for specific application needs. This in-depth guide explores the fundamentals of directives, their types, how to create custom directives, and advanced usage scenarios. We'll delve into attribute directives for styling and behavior, structural directives for DOM manipulation, and best practices to ensure efficient, maintainable code. Whether you're a beginner or an experienced developer, this content provides detailed insights, code examples, and tips to make your Angular applications more dynamic and effective."],keyPoints:["Directives: Instructions in the DOM that tell Angular to do something with a specific element or component.","Built-in Directives: Include ngIf, ngFor, ngClass, ngStyle for common tasks like conditional rendering and styling.","Custom Directives: User-defined directives to encapsulate reusable behavior, such as highlighting elements or validating inputs.","Types: Attribute directives change appearance or behavior; Structural directives alter DOM layout by adding/removing elements.","Lifecycle: Directives have hooks like ngOnInit and ngOnDestroy for initialization and cleanup.","Standalone Directives: In Angular 14+, directives can be standalone, simplifying usage without modules."],sections:[{id:"what-are-directives",heading:"What Are Directives in Angular?",content:"Directives are markers on DOM elements that Angular uses to attach behavior, transform the DOM, or render components. They are a core feature of Angular's declarative template syntax, allowing developers to create dynamic and interactive UIs without writing imperative JavaScript code directly in templates.",list:["Declared using the @Directive decorator","Can be applied to elements, components, or even other directives","Enhance HTML semantics, making templates more readable and maintainable","Integrate seamlessly with Angular's change detection for automatic updates"],additionalExplanation:"Directives bridge the gap between static HTML and dynamic application logic. For instance, a directive might highlight an element on hover or lazy-load images based on viewport visibility. Understanding directives is key to mastering Angular's template-driven approach, as they promote reusability and separation of concerns."},{id:"built-in-directives",heading:"Built-in Directives",content:"Angular provides a set of built-in directives out of the box, categorized into attribute and structural types. These handle common scenarios like conditional rendering, looping, and styling, reducing the need for custom implementations in basic cases.",list:["Attribute Directives: ngClass (conditional classes), ngStyle (inline styles), ngModel (two-way binding)","Structural Directives: *ngIf (conditional display), *ngFor (looping over collections), *ngSwitch (switch-case logic)","Other: [hidden] (toggle visibility), [attr] (dynamic attributes), [style] (dynamic styles)"],additionalExplanation:"Built-in directives are imported from CommonModule and can be used directly in templates. They are optimized for performance and integrate with Angular's renderer for safe DOM manipulation. For complex needs, built-in directives serve as a foundation for creating custom ones."},{id:"custom-directives",heading:"Custom Directives",content:"Custom directives allow developers to create reusable behaviors not covered by built-in ones. They can respond to events, manipulate host elements, or inject dependencies, making them versatile for application-specific logic.",list:["Created with @Directive({ selector: '[appCustom]' })","Can use @Input for data binding, @Output for events, @HostListener for event handling","Support dependency injection via constructor for services","Can be attribute-based (no template changes) or structural (with template manipulation)"],additionalExplanation:"Custom directives encapsulate logic that would otherwise clutter components, promoting cleaner code. For example, a custom directive could implement drag-and-drop functionality or auto-focus inputs. In larger applications, they enhance modularity by allowing behaviors to be applied declaratively across multiple components."},{id:"attribute-vs-structural",heading:"Attribute vs Structural Directives",content:"Directives are broadly divided into attribute and structural types based on their impact on the DOM.",list:["Attribute Directives: Modify the appearance or behavior of an element without changing the DOM structure (e.g., changing color on hover).","Structural Directives: Alter the DOM layout by adding, removing, or manipulating elements (e.g., conditionally rendering a section with *ngIf). Identified by a leading asterisk (*) in templates."],additionalExplanation:"Structural directives use TemplateRef and ViewContainerRef for DOM manipulation, allowing creation of embedded views. Attribute directives often use ElementRef or Renderer2 for safe access to the host element. Choosing the right type depends on whether you need to change 'what' is rendered (structural) or 'how' it's rendered (attribute)."},{id:"lifecycle-and-advanced-features",heading:"Lifecycle Hooks and Advanced Features",content:"Custom directives inherit lifecycle hooks similar to components, enabling timed executions. Advanced features include host bindings and multi-element selectors.",list:["Lifecycle Hooks: ngOnChanges, ngOnInit, ngDoCheck, ngOnDestroy for managing state and resources.","@HostBinding: Binds properties or classes to the host element (e.g., @HostBinding('style.backgroundColor') color: string;).","@HostListener: Listens to host events (e.g., @HostListener('mouseenter') onMouseEnter() {}).","Multi-Element Directives: Use selectors like '[appHighlight] p' to apply to multiple elements."],additionalExplanation:"Leverage hooks for initialization (e.g., setting up event listeners in ngOnInit) and cleanup (e.g., removing listeners in ngOnDestroy to prevent memory leaks). Advanced usage includes creating directive compositions or using them with Angular forms for custom validators."},{id:"standalone-directives",heading:"Standalone Directives",content:"Introduced in Angular 14, standalone directives simplify usage by not requiring declaration in NgModules, aligning with the shift towards module-less architecture.",list:["Marked with standalone: true in @Directive","Import dependencies directly in the imports array","Easily shareable across standalone components or modules","Enhance tree-shaking for smaller bundles"],additionalExplanation:"Standalone directives reduce boilerplate in modern Angular apps. They can be imported directly into components, making them ideal for libraries or micro-frontends. During migration, add standalone: true and move to direct imports."}],codeExamples:[{title:"Basic Attribute Directive Example",language:"typescript",code:`import { Directive, ElementRef, HostListener } from '@angular/core';

@Directive({
  selector: '[appHighlight]',
  standalone: true
})
export class HighlightDirective {
  constructor(private el: ElementRef) {}

  @HostListener('mouseenter') onMouseEnter() {
    this.highlight('yellow');
  }

  @HostListener('mouseleave') onMouseLeave() {
    this.highlight(null);
  }

  private highlight(color: string | null) {
    this.el.nativeElement.style.backgroundColor = color;
  }
}`,description:"A custom attribute directive that highlights the host element on mouse enter and removes it on leave."},{title:"Structural Directive Example",language:"typescript",code:`import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appUnless]',
  standalone: true
})
export class UnlessDirective {
  private hasView = false;

  constructor(private templateRef: TemplateRef<any>, private viewContainer: ViewContainerRef) {}

  @Input() set appUnless(condition: boolean) {
    if (!condition && !this.hasView) {
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.hasView = true;
    } else if (condition && this.hasView) {
      this.viewContainer.clear();
      this.hasView = false;
    }
  }
}`,description:"A custom structural directive that renders the template only if the condition is false, similar to the opposite of *ngIf."},{title:"Directive with Input and HostBinding Example",language:"typescript",code:`import { Directive, HostBinding, Input } from '@angular/core';

@Directive({
  selector: '[appBorder]',
  standalone: true
})
export class BorderDirective {
  @Input() appBorder: string = '1px solid black';

  @HostBinding('style.border') get border() {
    return this.appBorder;
  }
}`,description:"An attribute directive that applies a dynamic border style to the host element via input binding."},{title:"Using Directives in Template Example",language:"html",code:`<div appHighlight>Hover me to highlight!</div>
<p *appUnless="condition">This shows if condition is false.</p>
<button [appBorder]="'2px dashed red'">Styled Button</button>`,description:"Template usage demonstrating application of custom directives."}],bestPractices:["Keep directives focused: Follow the single responsibility principle; one directive per behavior.","Use Renderer2 for DOM manipulation: Avoid direct ElementRef access for server-side rendering compatibility.","Handle lifecycle properly: Always clean up in ngOnDestroy to prevent memory leaks, especially with subscriptions or event listeners.","Prefer standalone directives: For new projects, use standalone to reduce module clutter and improve modularity.","Test directives in isolation: Use Angular's testing utilities to verify behavior without full components.","Document selectors and inputs: Clearly comment directive usage for team collaboration.","Optimize for performance: Avoid expensive operations in frequently triggered hooks; leverage change detection strategies.","Combine with other features: Integrate directives with pipes, services, or animations for richer functionality.","Avoid overusing structural directives: They can impact performance; use attribute directives where possible for lighter DOM changes."]};function v(n,c){n&1&&(i(0,"div"),e(1," Always visible "),t())}function y(n,c){n&1&&(i(0,"div"),e(1," Only admin role sees this "),t())}function f(n,c){n&1&&(i(0,"div"),e(1," Only admin role sees this "),t())}var I=(()=>{class n{constructor(){this.content=h,this.visible=!1}static{this.\u0275fac=function(o){return new(o||n)}}static{this.\u0275cmp=d({type:n,selectors:[["app-directive"]],decls:136,vars:10,consts:[[3,"title","tags","paragraphs","sections","codeExamples","bestPractices","keyPoints"],[1,"container"],[1,"live-demo"],[4,"appVisibleIf"],[1,"btn","btn--primary",3,"click"]],template:function(o,a){o&1&&(i(0,"app-topic-template",0)(1,"div",1)(2,"h3"),e(3,"Angular Directives"),t(),i(4,"p"),e(5," Directives are one of the core building blocks in Angular that allow developers to extend the behavior of HTML elements. They provide a way to manipulate the DOM, apply dynamic styling, control rendering, and add custom logic to elements without creating new components. Directives help keep templates clean, reusable, and maintainable by encapsulating behavior in a structured and reusable way. "),t(),i(6,"p"),e(7," Angular provides several built-in directives that help developers manage dynamic UI behavior such as conditionally displaying elements, looping through collections, or applying styles. In addition to built-in directives, developers can also create custom directives to implement reusable logic tailored to specific application needs. "),t(),i(8,"h3"),e(9,"Types of Angular Directives"),t(),i(10,"p"),e(11," Angular directives are generally categorized into three main types based on their purpose and functionality. "),t(),i(12,"h4"),e(13,"1. Component Directives"),t(),i(14,"ul")(15,"li"),e(16," Components are technically directives with a template. "),t(),i(17,"li"),e(18," They define a custom HTML element with its own view, styles, and behavior. "),t(),i(19,"li"),e(20," Components encapsulate UI structure and business logic together. "),t()(),i(21,"h4"),e(22,"2. Structural Directives"),t(),i(23,"ul")(24,"li"),e(25," Structural directives modify the DOM layout by adding, removing, or rearranging elements. "),t(),i(26,"li"),e(27," They typically use the "),i(28,"code"),e(29,"*"),t(),e(30," syntax. "),t(),i(31,"li"),e(32," Common examples include: "),i(33,"ul")(34,"li")(35,"code"),e(36,"*ngIf"),t(),e(37," \u2014 conditionally adds or removes elements."),t(),i(38,"li")(39,"code"),e(40,"*ngFor"),t(),e(41," \u2014 repeats elements for each item in a list."),t(),i(42,"li")(43,"code"),e(44,"*ngSwitch"),t(),e(45," \u2014 displays elements based on conditions."),t()()(),i(46,"li"),e(47," Structural directives work by transforming the DOM structure during rendering. "),t()(),i(48,"h4"),e(49,"3. Attribute Directives"),t(),i(50,"ul")(51,"li"),e(52," Attribute directives change the appearance or behavior of existing DOM elements without altering the structure. "),t(),i(53,"li"),e(54," They are applied as HTML attributes. "),t(),i(55,"li"),e(56," Examples include: "),i(57,"ul")(58,"li")(59,"code"),e(60,"ngClass"),t(),e(61," \u2014 dynamically adds or removes CSS classes."),t(),i(62,"li")(63,"code"),e(64,"ngStyle"),t(),e(65," \u2014 applies inline styles dynamically."),t()()()(),i(66,"h3"),e(67,"Custom Directives"),t(),i(68,"p"),e(69," Custom directives allow developers to create reusable behavior that can be applied across multiple components. Instead of repeating logic in templates, custom directives encapsulate specific interactions or DOM manipulations in a single reusable unit. This improves code reusability, readability, and maintainability. "),t(),i(70,"p"),e(71," Custom directives are especially useful for handling common UI interactions such as highlighting elements, handling permissions, custom animations, tracking user actions, or applying dynamic styling based on conditions. "),t(),i(72,"h4"),e(73,"Creating a Custom Attribute Directive"),t(),i(74,"p"),e(75," To create a custom directive, Angular provides the "),i(76,"code"),e(77,"@Directive"),t(),e(78," decorator. Developers define a selector that is used as an attribute in HTML, and then implement logic inside the directive class. "),t(),i(79,"p"),e(80," In this example, the directive applies a background color to any element that uses the "),i(81,"code"),e(82,"appHighlight"),t(),e(83," attribute. "),t(),i(84,"h4"),e(85,"Using a Custom Directive"),t(),i(86,"pre"),e(87,`<p appHighlight>This text is highlighted using a custom directive.</p>
`),t(),i(88,"h3"),e(89,"Key Features of Custom Directives"),t(),i(90,"ul")(91,"li")(92,"strong"),e(93,"Reusability:"),t(),e(94," Write logic once and apply it across multiple components. "),t(),i(95,"li")(96,"strong"),e(97,"Separation of Concerns:"),t(),e(98," Keeps templates clean by moving behavior into reusable classes. "),t(),i(99,"li")(100,"strong"),e(101,"DOM Interaction:"),t(),e(102," Can modify styles, attributes, or respond to events. "),t(),i(103,"li")(104,"strong"),e(105,"Event Handling:"),t(),e(106," Listen to events like click, hover, focus, etc. "),t(),i(107,"li")(108,"strong"),e(109,"Dynamic Behavior:"),t(),e(110," Apply logic based on inputs or external data. "),t()(),i(111,"h3"),e(112,"Demo of Custom Directives"),t(),i(113,"div",2),m(114,v,2,0,"div",3)(115,y,2,0,"div",3)(116,f,2,0,"div",3),i(117,"button",4),p("click",function(){return a.visible=!a.visible}),e(118,"give me access"),t()(),i(119,"h3"),e(120,"Best Practices for Using Directives"),t(),i(121,"ul")(122,"li"),e(123," Keep directives focused on a single responsibility. "),t(),i(124,"li"),e(125," Avoid excessive DOM manipulation; use Angular bindings where possible. "),t(),i(126,"li"),e(127," Use input properties to make directives configurable and flexible. "),t(),i(128,"li"),e(129," Prefer directives for behavior reuse instead of duplicating template logic. "),t(),i(130,"li"),e(131," Combine directives with standalone components for modern Angular architecture. "),t()(),i(132,"h3"),e(133,"Summary"),t(),i(134,"p"),e(135," Directives enhance Angular applications by enabling reusable behaviors and dynamic UI manipulation. Built-in directives simplify common tasks, while custom directives allow developers to extend functionality based on specific application needs. Proper use of directives leads to cleaner templates, improved maintainability, and scalable application architecture. "),t()()()),o&2&&(r("title",a.content.title)("tags",a.content.tags)("paragraphs",a.content.paragraphs)("sections",a.content.sections)("codeExamples",a.content.codeExamples)("bestPractices",a.content.bestPractices)("keyPoints",a.content.keyPoints),s(114),r("appVisibleIf",!0),s(),r("appVisibleIf","admin"),s(),r("appVisibleIf",a.visible))},dependencies:[u,l],encapsulation:2})}}return n})();export{I as DirectiveExample};
