import{a as v}from"./chunk-FEIPXN7P.js";import{b as F,c as k,d as B,e as N}from"./chunk-LMJIRV6F.js";import{b as D}from"./chunk-LDGWIROF.js";import{i as A,j as M,k as _}from"./chunk-XGBKVH7G.js";import{Aa as a,Cb as t,Db as p,Fb as S,Ib as d,Jb as c,Kb as u,Nb as C,Oa as E,Ob as l,Pb as T,Qb as b,Rb as I,Sb as x,cb as f,db as P,eb as w,fb as n,gb as e,hb as h}from"./chunk-ESOSN4X2.js";var W={title:"Angular Pipes: In-Depth Explanation, Built-in & Custom Pipes, Pure vs Impure, and Best Practices",tags:["Angular","Pipes","Custom Pipes","Pure Pipes","Impure Pipes","Transformations","Best Practices","Performance"],paragraphs:["Pipes in Angular are simple yet extremely powerful tools for transforming displayed values right inside templates. They allow developers to format, filter, sort, or convert data declaratively without cluttering component logic or writing complex expressions in HTML. Pipes promote clean, readable templates and reusable transformation logic. This comprehensive guide covers everything about Angular pipes: how they work, built-in pipes, creating custom pipes, the critical difference between pure and impure pipes, performance considerations, and advanced usage patterns to help you write more maintainable and efficient Angular applications."],keyPoints:["Pipes: Functions that transform values for display in templates using the | (pipe) operator.","Built-in Pipes: Date, Currency, UpperCase, LowerCase, Decimal, Percent, Json, Async, Slice, TitleCase, and more.","Custom Pipes: Developer-created pipes for application-specific transformations (e.g., formatting phone numbers, masking data).","Pure vs Impure: Pure pipes run only when input reference changes (default, performant); impure pipes run on every change detection cycle.","Chaining: Multiple pipes can be chained for sequential transformations.","Standalone Pipes: In Angular 14+, pipes can be standalone, eliminating the need for NgModule declarations."],sections:[{id:"what-are-pipes",heading:"What Are Pipes in Angular?",content:"Pipes are pure functions (by default) that take an input value and return a transformed output. They are applied directly in templates using the pipe operator (|), making data presentation logic declarative and easy to read. Pipes do not modify the original data \u2014 they only transform what is displayed.",list:["Syntax: {{ value | pipeName : arg1 : arg2 }}","Can accept parameters and be chained: {{ value | pipe1 | pipe2: param }}","Execute during change detection when the bound value changes","Help keep components focused on business logic instead of formatting","Support both synchronous and asynchronous values (especially with async pipe)"],additionalExplanation:"Pipes are one of Angular's most elegant features for keeping templates clean. Instead of writing complex expressions or calling component methods in templates (which can hurt performance), you delegate formatting to pipes. This improves readability, testability, and reusability across the application."},{id:"built-in-pipes",heading:"Built-in Pipes",content:"Angular ships with a rich set of built-in pipes covering the most common formatting needs. These pipes are imported from CommonModule and ready to use in any template.",list:["DatePipe: Formats dates (short, medium, long, custom patterns)","CurrencyPipe: Formats numbers as currency with symbol and decimal places","DecimalPipe: Formats numbers with specific digits (before/after decimal)","PercentPipe: Converts number to percentage","UpperCasePipe / LowerCasePipe / TitleCasePipe: Changes text case","JsonPipe: Pretty-prints objects for debugging","AsyncPipe: Subscribes to Observables/Promises and returns latest value (unsubscribes automatically)","SlicePipe: Extracts a portion of array or string","KeyValuePipe: Iterates over object keys/values","I18nSelectPipe / I18nPluralPipe: Handles internationalization and pluralization"],additionalExplanation:"The async pipe is particularly powerful \u2014 it handles subscription management and prevents memory leaks, making it a must-use with Observables in templates. Built-in pipes are pure by default and highly optimized."},{id:"custom-pipes",heading:"Creating Custom Pipes",content:"When built-in pipes don't meet your needs, you create custom pipes. They follow the same pattern: implement the PipeTransform interface and decorate with @Pipe.",list:["Use @Pipe({ name: 'appCustom', pure: true })","Implement transform(value: any, ...args: any[]): any","Can be pure (default) or impure (pure: false)","Support dependency injection (e.g., inject services for formatting rules)","Standalone pipes (Angular 14+) use standalone: true and direct imports"],additionalExplanation:"Custom pipes are ideal for domain-specific formatting (phone numbers, credit card masking, file size conversion, status badges, etc.). They encapsulate transformation logic in one place, making it reusable across components and easy to maintain or unit test."},{id:"pure-vs-impure",heading:"Pure vs Impure Pipes \u2013 Performance & Behavior",content:"The most important decision when creating a pipe is whether it should be pure or impure. This setting dramatically affects when the pipe executes and its performance impact.",list:["Pure Pipes (default, pure: true): Only re-execute when Angular detects a change in the input reference (primitive value change or object/array reference change). Extremely performant.","Impure Pipes (pure: false): Execute on every change detection cycle \u2014 even if inputs haven't changed. Useful when the pipe depends on internal/external state or mutates input.","When to use impure: When transforming mutable objects, using external data, or depending on time/current user settings.","Performance warning: Impure pipes can cause significant overhead in large applications with frequent change detection cycles."],additionalExplanation:"Always prefer pure pipes whenever possible. Use immutable data patterns (create new objects/arrays) to trigger pure pipes correctly. Impure pipes should be used sparingly and only when truly necessary (e.g., a pipe that formats based on current locale or user role)."},{id:"advanced-usage",heading:"Advanced Pipe Usage and Patterns",content:"Pipes become even more powerful when combined with other Angular features and used in creative ways.",list:["Chaining pipes: {{ user.name | uppercase | slice:0:10 }}","Async pipe with fallback: {{ (user$ | async)?.name || 'Loading...' }}",'Pipes with ngFor: *ngFor="let item of items | filter:searchText"',"Stateful pipes: Impure pipes can maintain internal state (rarely recommended)","Testing pipes: Easy to unit test since they are pure functions (most cases)"],additionalExplanation:"Combining async pipe with map/filter operators (via rxjs) in templates can create powerful reactive displays without component code. Custom pipes can also be used in reactive forms validators or even in component logic (though template usage is preferred)."}],codeExamples:[{title:"Built-in Pipes Usage Example",language:"html",code:`<p>Today: {{ today | date:'fullDate' }}</p>
<p>Price: {{ price | currency:'USD':'symbol':'1.2-2' }}</p>
<p>Percent: {{ ratio | percent:'1.1-1' }}</p>
<p>JSON: {{ object | json }}</p>
<p>Name: {{ name$ | async }}</p>`,description:"Common usage of built-in pipes for formatting dates, currency, percentages, debugging, and handling async data."},{title:"Custom Pure Pipe \u2013 Phone Number Formatter",language:"typescript",code:`import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'phoneFormat',
  standalone: true
})
export class PhoneFormatPipe implements PipeTransform {
  transform(value: string): string {
    if (!value) return '';
    const cleaned = value.replace(/\\D/g, '');
    const match = cleaned.match(/^(\\d{3})(\\d{3})(\\d{4})$/);
    if (match) {
      return \`(\${match[1]}) \${match[2]}-\${match[3]}\`;
    }
    return value;
  }
}`,description:"A pure pipe that formats a 10-digit phone number into (XXX) XXX-XXXX style."},{title:"Custom Impure Pipe \u2013 Filter by Search Term",language:"typescript",code:`import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'filterBy',
  pure: false,
  standalone: true
})
export class FilterByPipe implements PipeTransform {
  transform(items: any[], searchText: string): any[] {
    if (!items || !searchText) return items;
    searchText = searchText.toLowerCase();
    return items.filter(item =>
      JSON.stringify(item).toLowerCase().includes(searchText)
    );
  }
}`,description:"An impure pipe that filters an array based on a search term. Impure because it needs to re-run when searchText changes but the items array reference stays the same."},{title:"Using Custom Pipes in Template",language:"html",code:`<p>Phone: {{ user.phone | phoneFormat }}</p>
<ul>
  <li *ngFor="let item of items | filterBy:searchText">
    {{ item.name }}
  </li>
</ul>`,description:"Practical usage of custom pipes directly in templates."}],bestPractices:["Always prefer pure pipes unless you have a strong reason to use impure.","Avoid heavy computations in pipes \u2014 especially impure ones \u2014 as they can run frequently.","Use async pipe for all Observables/Promises in templates to manage subscriptions automatically.","Keep pipes focused on one transformation task (single responsibility).","Create standalone pipes for modern Angular projects to reduce boilerplate.","Unit test pipes thoroughly \u2014 they are easy to test as pure functions.","Use immutable data patterns to make pure pipes work correctly and efficiently.","Avoid calling component methods in templates; move logic to pipes when appropriate.","Combine pipes with signals (Angular 16+) for even more reactive and performant templates.","Document custom pipes clearly: name, purpose, parameters, and whether pure/impure."]};var j=()=>["name","department","designation"],U=(o,m)=>m.id;function L(o,m){if(o&1&&(n(0,"tr")(1,"td"),t(2),e(),n(3,"td"),t(4),e(),n(5,"td"),t(6),e(),n(7,"td"),t(8),e(),n(9,"td"),t(10),l(11,"currency"),e()()),o&2){let s=m.$implicit;a(2),p(s.id),a(2),p(s.name),a(2),p(s.department),a(2),p(s.designation),a(2),p(x(11,5,s.salary,"INR","symbol","1.0-0"))}}function X(o,m){if(o&1&&(n(0,"tr")(1,"td"),t(2),e(),n(3,"td"),t(4),e(),n(5,"td"),t(6),e(),n(7,"td"),t(8),e(),n(9,"td"),t(10),l(11,"currency"),e()()),o&2){let s=m.$implicit;a(2),p(s.id),a(2),p(s.name),a(2),p(s.department),a(2),p(s.designation),a(2),p(x(11,5,s.salary,"INR","symbol","1.0-0"))}}var Q=(()=>{class o{constructor(){this.content=W,this.visible=!1,this.username="",this.day=new Date,this.employees=[{id:1,name:"Rahul Sharma",department:"IT",designation:"Software Engineer",salary:6e4},{id:2,name:"Priya Das",department:"HR",designation:"HR Manager",salary:55e3},{id:3,name:"Amit Roy",department:"Finance",designation:"Accountant",salary:5e4},{id:4,name:"Sneha Gupta",department:"Marketing",designation:"Marketing Executive",salary:52e3}],this.searchTerm="",this.searchTermNorm=""}static{this.\u0275fac=function(g){return new(g||o)}}static{this.\u0275cmp=E({type:o,selectors:[["app-directive"]],decls:132,vars:26,consts:[[3,"title","tags","paragraphs","sections","codeExamples","bestPractices","keyPoints"],[1,"live-demo"],["type","text","placeholder","Enter your name",3,"ngModelChange","ngModel"],["type","date","placeholder","Enter today's date",3,"ngModelChange","ngModel"],["type","text","placeholder","Search",3,"ngModelChange","ngModel"],["border","1","cellpadding","8","cellspacing","0"]],template:function(g,i){g&1&&(n(0,"app-topic-template",0)(1,"p"),t(2," Pipes in Angular are used to transform and format data directly within templates. They provide a clean and declarative way to modify how values are displayed without changing the underlying data. Pipes help keep component logic simple by moving display-related transformations into reusable functions. "),e(),n(3,"p"),t(4," Angular includes several built-in pipes for common data transformations such as formatting dates, currencies, numbers, JSON objects, and text casing. Developers can also create custom pipes to implement application-specific formatting or transformation logic. Pipes are applied in templates using the pipe ("),n(5,"code"),t(6,"|"),e(),t(7,") operator, making templates more readable and expressive. "),e(),n(8,"h3"),t(9,"Why Use Pipes?"),e(),n(10,"ul")(11,"li")(12,"strong"),t(13,"Cleaner Templates:"),e(),t(14," Simplifies data transformation directly in HTML. "),e(),n(15,"li")(16,"strong"),t(17,"Reusable Logic:"),e(),t(18," Write once and reuse across multiple components. "),e(),n(19,"li")(20,"strong"),t(21,"Separation of Concerns:"),e(),t(22," Keeps formatting logic separate from business logic. "),e(),n(23,"li")(24,"strong"),t(25,"Improved Readability:"),e(),t(26," Makes templates easier to understand. "),e()(),n(27,"h3"),t(28,"Common Built-in Pipes"),e(),n(29,"ul")(30,"li")(31,"strong"),t(32,"DatePipe:"),e(),t(33," Formats dates according to locale settings. "),e(),n(34,"li")(35,"strong"),t(36,"CurrencyPipe:"),e(),t(37," Formats numbers as currency values. "),e(),n(38,"li")(39,"strong"),t(40,"DecimalPipe:"),e(),t(41," Formats numeric values with decimal precision. "),e(),n(42,"li")(43,"strong"),t(44,"UpperCasePipe / LowerCasePipe:"),e(),t(45," Converts text casing. "),e(),n(46,"li")(47,"strong"),t(48,"JsonPipe:"),e(),t(49," Displays objects in JSON format for debugging. "),e(),n(50,"li")(51,"strong"),t(52,"AsyncPipe:"),e(),t(53," Automatically subscribes to Observables or Promises and updates values when data changes. "),e()(),n(54,"h3"),t(55,"Using Pipes in Templates"),e(),n(56,"p"),t(57," Pipes are applied using the "),n(58,"code"),t(59,"|"),e(),t(60," symbol followed by the pipe name. "),e(),n(61,"div",1)(62,"input",2),u("ngModelChange",function(r){return c(i.username,r)||(i.username=r),r}),e(),n(63,"input",3),u("ngModelChange",function(r){return c(i.day,r)||(i.day=r),r}),e(),h(64,"br"),n(65,"pre"),t(66),l(67,"uppercase"),l(68,"date"),e()(),n(69,"h3"),t(70,"Custom Pipes"),e(),n(71,"p"),t(72," Developers can create custom pipes when built-in pipes are not sufficient. Custom pipes are created using the "),n(73,"code"),t(74,"@Pipe"),e(),t(75," decorator and implement the "),n(76,"code"),t(77,"PipeTransform"),e(),t(78," interface. They allow custom transformation logic to be reused across templates. "),e(),h(79,"hr"),n(80,"div",1)(81,"input",4),u("ngModelChange",function(r){return c(i.searchTermNorm,r)||(i.searchTermNorm=r),r}),e(),n(82,"table",5)(83,"thead")(84,"tr")(85,"th"),t(86,"ID"),e(),n(87,"th"),t(88,"Name"),e(),n(89,"th"),t(90,"Department"),e(),n(91,"th"),t(92,"Designation"),e(),n(93,"th"),t(94,"Salary"),e()()(),f(95,L,12,10,"tr",null,U),l(97,"customFilter"),e(),h(98,"br")(99,"hr"),n(100,"input",4),u("ngModelChange",function(r){return c(i.searchTerm,r)||(i.searchTerm=r),r}),e(),n(101,"table",5)(102,"thead")(103,"tr")(104,"th"),t(105,"ID"),e(),n(106,"th"),t(107,"Name"),e(),n(108,"th"),t(109,"Department"),e(),n(110,"th"),t(111,"Designation"),e(),n(112,"th"),t(113,"Salary"),e()()(),f(114,X,12,10,"tr",null,U),l(116,"customFilter"),e()(),n(117,"h3"),t(118,"Pure vs Impure Pipes"),e(),n(119,"ul")(120,"li")(121,"strong"),t(122,"Pure Pipes:"),e(),t(123," Execute only when input values change (default behavior, better performance). "),e(),n(124,"li")(125,"strong"),t(126,"Impure Pipes:"),e(),t(127," Execute on every change detection cycle; used when data changes frequently without reference updates. "),e()(),n(128,"h3"),t(129,"Summary"),e(),n(130,"p"),t(131," Pipes enhance Angular templates by providing an efficient way to transform and format data. They improve code readability, encourage reuse, and help maintain a clean separation between presentation and logic. "),e()()),g&2&&(w("title",i.content.title)("tags",i.content.tags)("paragraphs",i.content.paragraphs)("sections",i.content.sections)("codeExamples",i.content.codeExamples)("bestPractices",i.content.bestPractices)("keyPoints",i.content.keyPoints),a(62),d("ngModel",i.username),a(),d("ngModel",i.day),a(3),S("      <p>",T(67,13,i.username),`</p>
      <p>`,b(68,15,i.day,"mediumDate"),`</p>
    `),a(15),d("ngModel",i.searchTermNorm),a(14),P(b(97,18,i.employees,i.searchTermNorm)),a(5),d("ngModel",i.searchTerm),a(14),P(I(116,21,i.employees,i.searchTerm,C(25,j))))},dependencies:[D,N,F,k,B,A,M,_,v],encapsulation:2})}}return o})();export{Q as PipeExample};
